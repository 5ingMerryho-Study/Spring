# 테스트란?

> 내가 의도했던 대로 코드가 정확하게 동작하는지를 확인해서, 만든 코드를 확신할 수 있게 하는 작업

## 웹 테스트의 단점

웹 화면을 통해서 테스트를 하는 방법은 가장 널리 알려지고 간단한 방법이지만, 하나의 기능(DAO 테스트 등)을 테스트하기 위해서 서비스 클래스, 컨트롤러, JSP 뷰 등 모든 레이어의 기능을 모두 만들고 테스트해야하는 단점이 있다.

또한, 특정 지점에서 오류가 났다면 어느 지점에서 오류가 났는지 파악하는 추가적인 노력이 필요하다.

## 작은 단위의 테스트(단위 테스트)

테스트 대상이 명확하다면 해당 대상에 집중하여 테스트하는 것이 이상적이다. 관심사의 분리를 통해 단위 테스트는 가능한 한 작고 독립적인 단위로 수행하는 것이 바람직하다.

단위 테스트에서 단위는 정해져있는 단위가 있는 것은 아니다. 기능 단위로 테스트 코드를 작성할 수 있고, 메서드 단위로 코드를 작성할 수 있다.

## JUnit 테스트로 전환

테스트 전용 클래스를 만들어 main() 메서드에서 직접 테스트를 수행할 수도 있지만, 보다 효율적으로는 JUnit을 활용해 테스트를 진행하는 방법이 있다. 제어의 역전(IoC) 원칙을 적용하면 JUnit 프레임워크를 통해 테스트 메서드를 자동으로 실행할 수 있다. 이를 위해 테스트할 메서드는 public으로 선언하고, @Test 어노테이션을 붙여주면 된다.

### 검증 코드의 전환

main() 메서드를 이용한 테스트에서는 결과를 검증할 때 if/else 문장을 통해 값이 일치하는지 검증했을 것이다. 하지만 JUnit 테스트에서는 matcher를 통해 검증할 수 있다.

assertThat() 메서드는 첫 번째 파라미터의 값을 매처(matcher)라고 불리는 조건으로 비교해서 일치하면 넘어가고, 아니면 테스트가 실패하도록 만들어준다.

```
// 조건문을 통한 검증
if(!user.getName().equals(user2.getName())) { ... }

// assertThat()을 통한 검증
assertThat(user2.getName(), is(user.getName()));
```

### 테스트 결과의 일관성

테스트 코드를 작성했다면, 동일한 입력에 대해 언제나 동일한 결과가 나와야 한다. 예를 들어, 회원가입 메서드를 테스트할 경우, 매번 같은 사용자 정보로 요청을 보내면 이미 등록된 사용자 때문에 테스트가 실패할 수 있다. 이처럼 DB를 초기화하지 않거나 외부 상태를 제대로 제어하지 않으면 테스트의 일관성이 깨진다. 테스트 결과가 외부 요인에 따라 달라져서는 안 되며, 항상 독립적이고 예측 가능해야 한다.

### 예외 조건에 대한 테스트

예를 들어, id 값에 해당하는 사용자를 불러오는 get() 메서드를 정의하고 테스트에서 이를 사용한다고 가정해보자. 그런데 해당 id에 매칭되는 사용자가 없다면 어떻게 될까?

이런 상황을 처리하기 위해, 테스트에서는 예외가 발생할 수 있음을 고려해 미리 예외 클래스를 정의하거나, 예상되는 예외를 명시하여 테스트가 실패하지 않도록 해야 한다.

![Image](https://github.com/user-attachments/assets/30d479ed-87ca-4d9d-b132-40068e52e355)

### 포괄적인 테스트

테스트를 진행할 때, 성공하는 테스트만 골라서 만드는 실수를 자주 하고는 한다. 예외적인 테스트 케이스를 피하고 정상적인 테스트 케이스만 작성한다면 예외적인 상황이 찾아왔을 때 기능의 성공을 보장할 수 없다. 그래서 테스트 케이스를 만들 때 부정적인 케이스를 만드는 습관을 들이는 것이 좋다.

## 테스트 주도 개발

> “실패한 테스트를 통과시키기 위한 목적이 아니라면, 코드를 작성하지 않는다.”

테스트 주도 개발(Test-Driven Development, TDD)은 테스트 코드를 먼저 작성한 뒤, 그 테스트를 통과시키기 위한 최소한의 실제 코드를 구현하는 방식으로 개발을 진행한다.  
개발자는 기능 구현보다 테스트 작성을 우선함으로써, 어떤 동작이 필요하고 어떤 결과가 나와야 하는지를 명확히 정의한다. 그 과정에서 자연스럽게 설계가 정리되며, 테스트 가능한 구조로 코드를 구성하게 된다.

TDD에서는 테스트를 작성하고 이를 성공시키는 코드를 만드는 작업의 주기를 짧게 가져가는 것을 권장한다. 또한, 최대한 주기를 짧게 가져가기 때문에 자연스럽게 단위 테스트도 만들 수 있다.

## 테스트를 위한 어플리케이션 컨텍스트 관리

JUnit 테스트는 각 테스트마다 새로운 **테스트 클래스 인스턴스**를 생성한다. 때문에 @Before 메서드에서 **어플리케이션 컨텍스트**를 생성하면, 테스트 메서드 수만큼 컨텍스트가 반복해서 만들어지게 된다.

이럴 때는 스프링이 JUnit을 이용하는 테스트 컨텍스트 프레임워크를 사용할 수 있다.

@Before 메서드에서 어플리케이션 컨텍스트를 지정하는 코드를 제거하고,

```
//@Before에서 제거할 코드
ApplicationContext context = new GenericXmlApplicationContext("applicationContext.xml");
```

다음과 같이 고쳐준다.

![Image](https://github.com/user-attachments/assets/4fc7c7a1-e3cf-439d-abe5-a2088bdfe8a6)

이렇게 사용되는 어플리케이션 컨텍스트는 싱글톤으로 생성되어 하나의 컨텍스트를 공유하여 사용한다.

![Image](https://github.com/user-attachments/assets/80fe7ac2-c1f2-43c8-99f5-8674c775a39e)

## DI와 테스트

Dao와 DB 커넥션 생성 클래스 사이에 인터페이스를 두어 Dao가 자신이 사용하는 오브젝트 클래스가 무엇인지 알 필요가 없도록 했다. 또한 DI를 통해 외부에서 사용할 오브젝트를 주입받기 때문에 오브젝트 생성에 대한 부담을 지지 않아도 된다. 코드의 수정 없이 의존 오브젝트를 바꿔가며 사용할 수 있다는 뜻이다.

만약, 의존 오브젝트가 절대 변하지 않기 때문에 인터페이스를 참조하지 않고 직접 구현하여 사용한다는 주장은 어떨까?

책에서는 3가지 근거로 인터페이스를 통한 DI를 권장하고 있다.

1\. 소프트웨어 개발에서 "절대"란 없다. 만약 분리하지 않은 상태의 개발을 진행하던 중 변경이 일어나게 된다면 수정에 들어가는 시간과 비용을 추가적으로 지불해야 한다.

2\. 클래스의 구현 방식이 변경되지 않더라도 DI를 적용한다면 다른 차원의 서비스를 도입할 수 있다. 부가기능을 추가한다고 했을 때 기존 코드를 수정할 필요가 없기 때문에 간단하게 추가가 가능해진다.

3\. 테스트에 유리하다. 가능한 한 작은 단위의 대상에 국한해서 테스트를 진행할 수 있도록 하는 것이 중요한데, DI를 이용해서 작은 단위의 대상에 대해 독립적으로 만들어지고 실행되게 할 수 있다.

> @DirtiesContext 어노테이션  
> 테스트 메서드에서 어플리케이션 컨텍스트의 구성이나 상태를 변경한다는 것을 테스트 컨텍스트 프레임워크에 알려준다.

## 학습 테스트

보통은 자신이 작성한 코드에 대해 테스트를 작성하지만, 본인이 작성하지 않은 코드에 대해서 테스트를 작성하는 것을 학습 테스트라고 한다.

학습 테스트의 목적은 자신이 사용한 API나 프레임워크의 기능을 테스트로 보면서 익히려는 것이 주요 목적이다. 따라서 테스트라고 불리지만 프레임워크나 기능에 대한 검증이 목적이 아니다.

### 학습 테스트의 장점

1\. 다양한 조건에 따른 기능을 손쉽게 확인해볼 수 있다.

2\. 학습 테스트 코드를 개발 중에 참고할 수 있다. 완성된 코드를 보는 것이 아니라 다양한 기능과 조건에 대한 테스트 코드를 남겨놀 수 있기 때문이다.

3\. 프레임워크나 제품을 업그레이드할 때 호환성 검증을 도와준다.

4\. 테스트 작성에 대한 좋은 훈련이 된다.

5\. 새로운 기술을 공부하는 과정이 즐거워진다.

## 버그 테스트

버그 테스트란 코드에 오류가 있을 때 그 오류를 가장 잘 드러내줄 수 있는 테스트를 말한다. 버그 테스트는 일단 실패하도록 만들어야 한다. 버그가 원인이 되서 테스트가 실패하는 코드를 만드는 것이다. 그 후, 버그 테스트가 성공할 수 있도록 어플리케이션 코드를 수정한다. 테스트가 성공하면 버그가 수정된 것이다.

### 버그 테스트의 필요성과 장점

1\. 테스트의 완성도를 높여준다. 미처 검증하지 못했던 부분에 대해 바로잡을 수 있도록 해주기 때문이다.

2\. 버그의 내용을 명확하게 분석해준다.

3\. 기술적인 문제를 해결하는데 도움이 된다.

> 동등분할  
> 같은 결과를 내는 값의 범위를 구분해서 각 대표값으로 테스트하는 방법.  
>   
> 경계값 분석  
> 에러는 동등분할 범위의 경계에서 주로 많이 발생한다는 특징을 이용해서 경계의 근처에 있는 값을 이용해 테스트하는 방법.

## 2장 정리

-   **자동화와 빠른 실행**: 테스트는 수동 작업 없이 자동화되어야 하며, 빠르게 실행될 수 있어야 한다.
-   **JUnit 프레임워크 활용**: main() 메서드를 이용한 테스트보다는 **JUnit 프레임워크**를 활용하는 것이 테스트 작성 및 관리에 훨씬 편리한다.
-   **결과의 일관성**: 테스트 결과는 항상 일관적이어야 합니다. 코드 변경 없이 환경이나 테스트 실행 순서에 따라 결과가 달라져서는 안 된다.
-   **포괄적인 테스트 작성**: 충분한 검증을 할 수 있도록 테스트는 포괄적으로 작성해야 한다. 검증 범위가 좁은 테스트는 아예 없는 것보다 나쁠 수 있다.
-   **잦은 테스트 수행**: 코드 작성과 테스트 수행 간격이 짧을수록 개발 효율성이 높아진다.
-   **테스트하기 쉬운 코드**: 테스트하기 쉬운 코드가 곧 좋은 코드다. 코드 설계 시 테스트 용이성을 고려해야 한다.
-   **테스트 주도 개발(TDD) 활용**: 테스트를 먼저 작성하고, 해당 테스트를 통과시키는 코드를 개발해 나가는 **테스트 주도 개발(TDD)** 방법론은 매우 유용하다.
-   **테스트 코드 리팩토링**: 애플리케이션 코드와 마찬가지로 테스트 코드도 지속적인 **리팩토링**이 필요하다.
-   **@Before, @After 활용**: @Before와 @After 어노테이션을 사용하여 각 테스트 메서드 실행 전의 공통 준비 작업과 실행 후의 정리 작업을 효율적으로 처리할 수 있다.
-   **스프링 테스트 컨텍스트 프레임워크**: **스프링 테스트 컨텍스트 프레임워크**를 이용하면 애플리케이션 컨텍스트를 효율적으로 관리하여 테스트 성능을 향상시킬 수 있다.
-   **애플리케이션 컨텍스트 공유**: 동일한 설정 파일을 사용하는 테스트들은 하나의 애플리케이션 컨텍스트를 공유하여 재사용성을 높인다.
-   **@Autowired를 통한 DI**: @Autowired 어노테이션을 사용하여 스프링 컨텍스트의 빈(Bean)들을 테스트 객체에 의존성 주입(DI)할 수 있다.
-   **학습 테스트 작성**: 새로운 기술의 사용법을 익히고 이해를 돕기 위해 학습 테스트(Learning Test)를 작성하는 것이 좋다.
-   **버그 테스트 작성**: 오류가 발견될 경우, 해당 오류를 재현하는 버그 테스트(Bug Test)를 미리 만들어 두면 재발 방지에 유용하다.

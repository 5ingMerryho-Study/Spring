# 테스트

스프링이 개발자에게 제공하는 가장 중요한 가치가 무엇이냐고 질문한다면, 필자는 객체지향과 테스트를 대답한다고 한다.

스프링의 핵심인 IoC(제어의 역전)와 DI(의존성 주입)는 오브젝트의 설계와 생성, 관계, 사용에 관한 기술이다.

스프링은 IoC/DI를 이용해 객체지향 프로그래밍 언어의 근본과 가치를 개발자가 손쉽게 적용하고 사용할 수 있게 도와주는 기술이다.

동시에 스프링은 복잡한 엔터프라이즈 애플리케이션을 효과적으로 개발하기 위한 기술이다.

이러한 복잡한 애플리케이션을 개발하는 데 필요한 도구 하나는 '객체지향 기술'이다.

그리고 다른 하나의 도구는 '테스트'이다.

스프링으로 개발을 하면서 테스트를 만들지 않는다면 이는 스프링이 지닌 가치의 절반을 포기하는 셈이다.

스프링 개발자라면 테스트 작성 방법과 이를 효과적으로 개발에 활용하는 전략을 알아야 하며, 이를 실전에 적용할 수 있어야 한다.

또한 테스트는 스프링을 학습하는 데 있어 가장 효과적인 방법의 하나다.

***2장에서는 테스트란 무엇이며, 그 가치와 장점, 활용 전략, 스프링과의 관계를 살펴본다.***

## UserDaoTest 다시보기 - 테스트의 유용성

만든 코드는 어떤 방법으로든 테스트를 진행해야 한다.

테스트란 결국 내가 예상하고 의도했던 대로 코드가 정확히 동작하는지를 확인해서, 만든 코드를 확신할 수 있게 해주는 작업이다.

또한 테스트의 결과가 원하는 대로 나오지 않는 경우에는 코드나 설계에 결함이 있음을 알 수 있다.

이를 통해 코드의 결함을 제거해가는 작업, 일명 디버깅을 거치게 되고, 결국 최종적으로 테스트가 성공하면 모든 결함이 제거됐다는 확신을 얻을 수 있다.

## UserDaoTest 다시보기 - 웹을 통한 DAO 테스트 방법의 문제점

웹 화면을 통해 테스트를 진행하는 것에는 문제가 있는데, 테스트하고 싶었던 건 UserDao였는데 다른 계층의 코드와 컴포넌트, 심지어 서버의 설정 상태까지 모두 테스트에 영향을 줄 수 있기 때문에 이런 방식(웹을 통한 테스트)으로 테스트하는 것은 번거롭고, 오류가 있을 때 빠르고 정확하게 대응하기가 힘들다는 문제가 있다.

## UserDaoTest 다시보기 - 작은 단위의 테스트

테스트하고자 하는 대상이 명확하다면 그 대상에만 집중해서 테스트하는 것이 바람직하다.

한꺼번에 너무 많은 것을 몰아서 테스트하면 테스트 수행 과정도 복잡해지고, 오류가 발생했을 때 정확한 원인을 찾기가 힘들어진다.

따라서 테스트는 가능하면 작은 단위로 쪼개서 집중해서 할 수 있어야 한다.

관심사의 분리라는 원리가 여기에도 적용된다.

테스트의 관심이 다르다면 테스트할 대상을 분리하고 집중해서 접근해야 한다.

이렇게 작은 단위의 코드에 대해 테스트를 수행하는 것을 '단위 테스트'라고 한다.

여기서 말하는 단위란, 그 크기와 범위가 어느 정도인지 딱 정해진 건 아니다.

크게는 사용자 관리 기능을 모두 통틀어서 하나의 단위로 볼 수도 있고, 작게 보자면 UserDao의 add() 메소드 하나만 가지고 하나의 단위라고 생각할 수도 있다.

충분히 하나의 관심에 집중해서 효율적으로 테스트할 만한 범위의 단위라고 보면 된다.

단위는 작을수록 좋다.

단위를 넘어서는 다른 코드들은 신경 쓰지 않고, 참여하지도 않고 테스트가 동작할 수 있으면 좋다.

통제할 수 없는 외부의 리소스에 의존하는 테스트는 단위 테스트가 아니라고 보기도 한다.

개발된 흐름 전 과정을 하나로 묶어서 테스트할 필요가 있다.

각 단위 기능은 잘 동작하는데 묶어놓으면 안 되는 경우가 종종 발생하기 때문이다.

따라서 이런 길고 많은 단위가 참여하는 테스트도 언젠가는 필요하다.

때로는 단위 테스트 없이 바로 이런 긴 테스트만 하는 경우도 있다.

이때는 문제의 원인을 찾기가 매우 힘들다.

예외가 발생해도 그 이유를 찾는 데 많은 시간이 걸릴 수 있다.

또, 예외가 발생하지 않고 정상적으로 동작했는데 막상 결과가 원하는 대로 나오지 않을 수도 있다.

그런데 각 단위별로 테스트를 먼저 모두 진행하고 나서 이런 긴 테스트를 시작했으면 어떨까?

그래도 역시 예외가 발생하거나 테스트가 실패할 수는 있겠지만, 이미 각 단위별로 충분한 검증을 마치고 오류를 잡았으므로 훨씬 나을 것이다.

단위 테스트를 하는 이유는 개발자가 설계 만든 코드가 원래 의도한 대로 동작하는지를 개발자 스스로 빨리 확인받기 위해서다.

이때 확인의 대상과 조건이 간단하고 명확할수록 좋다.

그래서 작은 단위로 제한해서 테스트하는 것이 편리하다.

단위 테스트는 주로 개발자가 만든 코드를 스스로 확인하기 위해 사용하는데, 그래서 이를 개발자 테스트 또는 프로그래머 테스트라고도 한다.

우리가 만들고 개선한 코드가 처음 설계하고 의도한 대로 바르게 동작했는지를 확인하기 위해 개발자 입장에서 만든 것이므로 이를 개발자 테스트라고 부를 수도 있다.

## UserDaoTest 다시보기 - 자동수행 테스트 코드

테스트는 자동으로 수행되도록 코드로 만들어지는 것이 중요하다.

어떤 개발자는 모든 클래스를 스스로 자신을 테스트하는 main() 메서드를 갖고 있어야 한다고 주장하기도 한다.

굳이 모든 클래스의 main() 메서드에 테스트 코드가 들어가 있을 필요까지는 없겠지만, 어쨌든 테스트 자체가 사람의 수작업을 거치는 방법을 사용하기보다는 코드로 만들어져서 자동으로 수행될 수 있어야 한다는 건 매우 중요하다.

그런데 애플리케이션을 구성하는 클래스 안에 테스트 코드를 포함시키는 것보다는 별도로 테스트용 클래스를 만들어서 테스트 코드를 넣는 편이 낫다.

자동으로 수행되는 테스트의 장점은 자주 반복할 수 있다는 것이다.

번거로운 작업이 없고 테스트를 빠르게 실행할 수 있기 때문에 언제든 코드를 수정하고 나서 테스트를 해볼 수 있다.

때로는 단 한 줄의 코드를 건드렸는데 전체 기능에 영향을 주기도 한다.

## UserDaoTest 다시보기 - 지속적인 개선과 점진적인 개발을 위한 테스트

조금씩 기능을 더 추가해가면서 그에 대한 테스트도 함께 추가하는 식으로 점진적인 개발이 가능해진다.

테스트를 이용하면 새로운 기능도 기대한 대로 동작하는지 확인할 수 있을 뿐 아니라, 기존에 만들어뒀던 기능들이 새로운 기능을 추가하느라 수정한 코드에 영향을 받지 않고 여전히 잘 동작하는지를 확인할 수도 있다.

## UserDaoTest의 문제점

### 수동 확인 작업의 번거로움

UserDaoTest는 테스트를 수행하는 과정과 입력 데이터의 준비를 모두 자동으로 진행하도록 만들어졌다.

하지만 여전히 사람의 눈으로 확인하는 과정이 필요하다.

add()에서 User 정보를 DB에 등록하고, 이를 다시 get()을 이용해 가져왔을 때 입력한 값과 가져온 값이 일치하는지를 테스트 코드는 확인해주지 않는다.

단지 콘솔에 값만 출력해줄 뿐이다.

결국 그 콘솔에 나온 값을 보고 확인하는 것은 사람의 책임이다.

테스트 수행은 코드에 의해 자동으로 진행되긴 하지만 테스트의 결과를 확인하는 일은 사람의 책임이므로 완전히 자동으로 테스트되는 방법이라고 말할 수 없다.

검증해야 하는 양이 많고 복잡해지면 역시 불편함을 느낄 수밖에 없다.

또한 작은 차이는 미처 발견하지 못하고 넘어가는 실수를 할 가능성도 있다.

### 실행 작업의 번거로움

아무리 간단히 실행 가능한 main() 메서드라고 하더라도 매번 그것을 실행하는 것은 제법 번거롭다.

또한 그 결과를 눈으로 확인해서 기록하고, 이를 종합해서 전체 기능을 모두 테스트한 결과를 정리하려면 이것도 제법 큰 작업이 된다.

그래서 main() 메서드를 이용하는 방법보다 좀 더 편리하고 체계적으로 테스트를 진행하고 그 결과를 확인하는 방법이 절실히 필요하다.

## UserDaoTest 개선 - 테스트 검증의 자동화

첫 번째 문제점인 테스트 결과의 검증 부분을 코드로 만들어보자.

이 테스트를 통해 확인하고 싶은 사항은, add()에 전달한 User 오브젝트에 담긴 사용자 정보와 get()을 통해 다시 DB에서 가져온 User 오브젝트의 정보가 서로 정확히 일치하는가이다.

모든 테스트는 성공과 실패의 두 가지 결과를 가질 수 있다.

또 테스트의 실패는 테스트가 진행되는 동안에 에러가 발생해서 실패하는 경우와, 테스트 작업 중에 에러가 발생하진 않았지만 그 결과가 기대한 것과 다르게 나오는 경우로 구분해볼 수 있다.

## UserDaoTest 개선 - 테스트의 효율적인 수행과 결과 관리

### JUnit 테스트로 전환

새로 만들 테스트 메소드는 JUnit 프레임워크가 요구하는 조건 두가지를 따라야 한다.

첫째는 메소드가 public으로 선언돼야 하는 것이고, 다른 하나는 메소드에 @Test라는 어노테이션을 붙여주는 것이다.

#### JUnit 프레임워크에서 동작할 수 있는 테스트 메소드로 전환
```java
public class UserDaoTest {
  @Test // JUnit에게 테스트용 메서드임을 알려준다.
  public void addAndGet() throws SQLException {
    ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");

    UserDao dao = context.getBean("userDao", UserDao.class);
    ...
  }
}
```

JUnit은 전통적으로 public 메서드만을 테스트 메서드로 허용하고 있다.

마지막으로 @Test 어노테이션을 붙여주면 된다.

### 검증 코드 전환

테스트의 결과를 검증하는 if/else 문장을 JUnit이 제공하는 방법을 이용해 전환해보자.

```java
if (!user.getName().equals(user2.getName())) {
  ...
}
```

이 if 문장의 기능을 JUnit이 제공해주는 assertThat이라는 스태틱 메소드를 이용해 변경할 수 있다.

```java
assertThat(user2.getName(), is(user.getNAme())));
```

assertThat() 메소드는 첫 번째 파라미터의 값을 뒤에 나오는 매처(matcher)라고 불리는 조건으로 비교해서 일치하면 다음으로 넘어가고, 아니면 테스트가 실패하도록 만들어준다.

is()는 매처의 일종으로 equals()로 비교해주는 기능을 가졌다.

같은 방법으론 두 번째 if 문장도 다음과 같이 바꿀 수 있다.

```java
assertThat(user2.getPassword(), is(user.getPassword))):
```

JUnit은 예외가 발생하거나 assertThat()에서 실패하지 않고 테스트 메소드의 실행이 완료되면 테스트가 성공했다고 인식한다.

### JUnit 테스트 실행

테스트가 실패하면 OK 대신 FAILURES!! 라는 내용이 출력되고, 총 수행한 테스트 중에서 몇 개의 테스트가 실패했는지 보여준다.

함께 출력된 호출 스택을 살펴보면 실패한 원인이 무엇이고 테스트 코드에서 검증에 실패한 위치는 어디인지도 확인할 수 있다.

JUnit은 assertThat()을 이용해 검증 했을 때 기대한 결과가 아니면 이 AssertionError를 던진다.

따라서 assertThat()의 조건을 만족하지 못하면 테스트는 더 이상 진행되지 않고 JUnit은 테스트가 실패했음을 알게 된다.

테스트 수행 중에 일반 예외가 발생한 경우에도 마찬가지로 테스트 수행은 중단되고 테스트는 실패한다.

## 개발자를 위한 테스팅 프레임워크 JUnit

스프링을 학습하고 제대로 활용하려면 최소한의 JUnit 테스트 작성 방법과 실행 방법은 알고 있어야 한다.

## 개발자를 위한 테스팅 프레임워크 JUnit - 테스트 결과의 일관성

반복적으로 테스트를 했을 때 테스트가 실패하기도 하고 성공하기도 한다면 이는 좋은 테스트라고 할 수가 없다.

코드에 변경사항이 없다면 테스트는 항상 동일한 결과를 내야한다.

## 개발자를 위한 테스팅 프레임워크 JUnit - 동일한 결과를 보장하는 테스트

단위 테스트는 코드가 바뀌지 않는다면 매번 실행할 때마다 동일한 테스트 결과를 얻을 수 있어야 한다.

단위 테스트는 항상 일관성 있는 결과가 보장돼야 한다는 점을 잊어선 안 된다.

DB에 남아 있는 데이터와 같은 외부 환경에 영향을 받지 말아야 하는 것은 물론이고, 테스트를 실행하는 순서를 바꿔도 동일한 결과가 보장되도록 만들어야 한다.

## 포괄적인 테스트

테스트를 안 만드는 것도 위험한 일이지만, 성의 없이 테스트를 만드는 바람에 문제가 있는 코드인데도 테스트가 성공하게 만드는 건 더 위험하다.

특히 한 가지 결과만 검증하고 마는 것은 상당히 위험하다.

이런 테스트는 마치 하루에 두 번은 정확히 맞는다는 시계와 같을 수도 있다.

JUnit은 특정한 테스트 메소드의 실행 순서를 보장해주지 않는다.

테스트의 결과가 테스트 실행 순서에 영향을 받는다면 테스트를 잘못 만든 것이다.

모든 테스트는 실행 순서에 상관없이 독립적으로 항상 동일한 결과를 낼 수 있도록 해야 한다.

#### get() 메소드의 예외상황에 대한 테스트
```java
@Test(expected=EmptyResultDataAccessException.class) // 테스트 중에 발생할 것으로 기대하는 예외 클래스를 지정해준다.
public void getUserFailure() throws SQLException {
  ...
}
```

이 테스트에서 중요한 것은 @Test 어노테이션의 expected 엘리먼트이다.

expected는 테스트 메소드 실행 중에 발생하리라 기대하는 예외 클래스를 넣어주면 된다.

@Test에 expected를 추가해놓으면 보통의 테스트와는 반대로, 정상적으로 테스트 메소드를 마치면 테스트가 실패하고, expected에서 지정한 예외가 던져지면 테스트가 성공한다.

예외가 반드시 발생해야 하는 경우를 테스트하고 싶을 때 유용하게 쓸 수 있다.

## 포괄적인 테스트

개발자가 테스트를 직접 만들 때 자주 하는 실수가 하나 있다.

바로 성공하는 테스트만 골라서 만드는 것이다.

개발자는 머릿속으로 이 코드가 잘 돌아가는 케이스를 상상하면서 코드를 만드는 경우가 일반적이다.

그래서 테스트를 작성할 때도 문제가 될 만한 상황이나, 입력 값 등은 교묘히도 잘 피해서 코드를 만드는 습성이 있다.

이건 테스트 코드를 통한 자동 테스트뿐 아니라, UI를 통한 수동 테스트를 할 때도 빈번하게 발생하는 문제다.

이런 이유 때문에 QA팀이나 고객의 인수담당자에 의해 꼼꼼하게 준비된 시나리오를 따라 다양한 경우에 대한 전문적인 테스트가 수행될 필요가 있다.

개발자는 빨리 테스트를 만들어 성공하는 것을 보고 다음 기능으로 나아가고 싶어하기 때문에, 긍정적인 경우를 골라서 성공할 만한 테스트를 먼저 작성하게 되기가 쉽다.

그래서 테스트를 작성할 때 부정적인 케이스를 먼저 만드는 습관을 들이는 게 좋다.

## 테스트가 이끄는 개발 - 기능설계를 위한 테스트

getUserFailure() 테스트에 만들고 싶은 기능에 대한 조건과 행위, 결과에 대한 내용이 잘 표현되어 있다.

| |단계|내용|코드|
|---|---|---|---|
|조건|어떤 조건을 가지고|가져올 사용자 정보가 존재하지 않는 경우에|dao.deleteAll(); </br> assertThat(dao.getCount().is(0));|
|행위|무엇을 할 때|존재하지 않는 id로 get()을 실행하면|get("unknown_id");|
|결과|어떤 결과가 나온다|특별한 예외가 던져진다.|@Test(expecte=EmptyResultAccessException.class)|

이렇게 비교해보면 이 테스트 코드는 마치 잘 작성된 하나의 기능정의서처럼 보인다.

그래서 보통 기능설계, 구현, 테스트라는 일반적인 개발 흐름의 기능설계에 해당하는 부분을 이 테스트 코드가 일부분 담당하고 있다고 볼 수도 있다.

이런 식으로 추가하고 싶은 기능을 일반 언어가 아니라 테스트 코드로 표현해서, 마치 코드로 된 설계문서처럼 만들어놓은 것이라고 생각해보자.

그러고 나서 실제 기능을 가진 애플리케이션 코드를 만들고 나면, 바로 이 테스트를 실행해서 설계한 대로 코드가 동작하는지를 빠르게 검증할 수 있다.

만약 테스트가 실패하면 이때는 설계한 대로 코드가 만들어지지 않았음을 바로 알 수 있다.

그리고 문제가 되는 부분이 무엇인지에 대한 정보도 테스트 결과를 통해 얻을 수 있다.

다시 코드를 수정하고 테스트를 수행해서 테스트가 성공하도록 애플리케이션 코드를 계속 다듬어간다.

결국 테스트가 성공한다면, 그 순간 코드 구현과 테스트라는 두 가지 작업이 동시에 끝나는 것이다.

## 테스트가 이끄는 개발 - 테스트 주도 개발

만들고자 하는 기능의 내용을 담고 있으면서 만들어진 코드를 검증도 해줄 수 있도록 테스트 코드를 먼저 만들고, 테스트를 성공하게 해주는 코드를 작성하는 방식의 개발 방법이 있다.

이를 '테스트 주도 개발(TDD, Test Driven Development)'라고 한다.

또는 테스트를 코드보다 먼저 작성한다고 해서 '테스트 우선 개발(Test First Development)'라고 한다.

"실패한 테스트를 성공시키기 위한 목적이 아닌 코드는 만들지 않는다"는 것이 TDD의 기본 원칙이다.

이 원칙을 따랐다면 만들어진 모든 코드는 빠짐없이 테스트로 검증된 것이라고 볼 수 있다.

문제는 코드를 만들고 나서 시간이 많이 지나면 테스트를 만들기가 귀찮아진다는 점이다.

또, 작성한 코드가 많기 때문에 무엇을 테스트해야 할지 막막할 수도 있다.

결국 테스트 작성은 자꾸 뒷전으로 밀려나거나 점점 더 성의 없는 테스트를 만들게 될지도 모른다.

TDD는 아예 테스트를 먼저 만들고 그 테스트가 성공하도록 하는 코드만 만드는 식으로 진행하기 때문에 테스트를 빼먹지 않고 꼼꼼하게 만들어낼 수 있다.

또한 테스트를 작성하는 시간과 애플리케이션 코드를 작성하는 시간의 간격이 짧아진다.

사실 코드를 만들고 테스트를 수행할 때까지 걸리는 시간은 0에 가깝다.

이미 테스트를 만들어뒀기 때문에 코드를 작성하면 바로바로 테스트를 실행해볼 수 있기 때문이다.

그 덕분에 코드에 대한 피드백을 매우 빠르게 받을 수 있게 된다.

또, 매번 테스트가 성공하는 것을 보면서 작성한 코드에 대한 확신을 가질 수 있어, 가벼운 마음으로 다음 단계로 넘어갈 수가 있다.

한편으로는 자신감을, 다른 한편으로는 마음의 여유를 주는 방법이다.

TDD에서는 테스트 작성하고 이를 성공시키는 코드를 만드는 작업의 주기를 가능한 한 짧게 가져가도록 권장한다.

이렇게 머릿속에서 진행되는 테스트는 제약이 심하고, 오류가 많고, 나중에 다시 반복하기가 힘들다는 점이다.

그래서 차라리 머릿속에서 복잡하게 진행하던 작업을 실제 코드로 끄집어 내놓으면 이게 바로 TDD가 된다.

TDD는 처음에는 이상하게 보일지 모르겠지만 사실은 매우 자연스러우며, 한번 익숙해지고 나면 TDD가 아니고는 개발을 못하겠다고 할지도 모를 만큼 매력적인 방법이다.

TDD의 장점 중 하나는 코드를 만들어 테스트를 실행하는 그 사아의 간격이 매우 짧다는 점이다.

개발한 코드의 오류는 빨리 발견할수록 좋다.

빨리 발견된 오류는 쉽게 대응이 가능하기 때문이다.

진작에 간단한 테스트를 해봤으면 미리미리 쉽게 발견할 수 있었던 사소한 문제도, 나중에 많은 코드와 얽혀서 돌아가는 상황에서는 쉽게 찾지 못하는 경우가 많다.

하지만 이런 방법이 불편하다면 일정 분량의 코딩을 먼저 해놓고 빠른 시간 안에 테스트 코드를 만들어 테스트해도 상관없다.

테스트는 애플리케이션 코드보다 상대적으로 작성하기 쉬운데다 각 테스트가 독립적이기 때문에, 코드의 양에 비해 작성하는 시간은 얼마 걸리지 않는다.

게다가 테스트 덕분에 오류를 빨리 잡아낼 수 있어서 전체적인 개발 속도는 오히려 빨라진다.

테스트 코드를 만들지 않아도 언젠가는 웹 화면을 통한 테스트라도 하게 될 것이다.

이런 테스트의 비효율성을 생각해보면 미리미리 단위 테스트를 만들어서 코드를 검증해두는 편이 낫다.

## 테스트 코드 개선

JUnit 프레임워크는 테스트 메소드를 실행할 때 부가적으로 해주는 작업이 몇 가지 있다.

그중에서 테스트를 실행할 때마다 반복되는 준비 작업을 별도의 메소드에 넣게 해주고, 이를 매번 테스트 메소드를 실행하기 전에 먼저 실행시켜주는 기능이다.

## 테스트 코드 개선 - @Before

중복됐던 코드를 넣을 setUp()이라는 이름의 메소드를 만들고 테스트 메소드에 제거한 코드를 넣는다.

```java
@Before // JUnit이 제공하는 어노테이션, @Test 메소드가 실행되기 전에 먼저 실행돼야 하는 메소드를 정의한다.
public void setUp() {
  ... 
} 
```

JUnit이 하나의 테스트 클래스를 가져와 테스트를 수행하는 방식은 다음과 같다.

1. 테스트 클래스에서 @Test가 붙은 public이고 void형이며 파라미터가 없는 테스트 메소드를 모두 찾는다.
2. 테스트 클래스의 오브젝트를 하나 만든다.
3. @Before가 붙은 메소드가 있으면 실행한다.
4. @Test가 붙은 메소드를 하나 호출하고 테스트 결과를 저장해둔다.
5. @After가 붙은 메소드가 있으면 실행한다.
6. 나머지 테스트 메소드에 대해 2~5번을 반복한다.
7. 모든 테스트의 결과를 종합해서 돌려준다.

실제로는 이보다 더 복잡한데, 간단히 정리하면 JUnit 테스트는 위의 7단계를 거쳐서 진행된다고 볼 수 있다.

JUnit은 @Test가 붙은 메소드를 실행하기 전과 후에 각각 @Before와 @After가 붙은 메소드를 자동으로 실행한다.

대신 @Before나 @After 메소드를 테스트 메소드에서 직접 호출하지 않기 때문에 서로 주고받을 정보나 오브젝트가 있다면 인스턴스 변수를 이용해야 한다.

또 한 가지 꼭 기억해야 할 사항은 각 테스트 메소드를 실행할 때마다 테스트 클래스의 오브젝트를 새로 만든다는 점이다.

한번 만들어진 테스트 클래스의 오브젝트는 하나의 테스트 메소드를 사용하고 나면 버려진다.

테스트 클래스가 @Test 테스트 메소드를 두 개 갖고 있다면, 테스트가 실행되는 중에 JUnit은 이 클래스의 오브젝트를 두 번 만들 것이다.

그런데, 왜 테스트 메소드를 실행할 때마다 새로운 오브젝트를 만드는 것일까?

그냥 테스트 클래스마다 하나의 오브젝트만 만들어놓고 사용하는 편이 성능이 낫고 더 효율적이지 않을까?

JUnit 개발자는 각 테스트가 서로 영향을 주지 않고 독립적으로 실행됨을 확실히 보장해주기 위해 매번 새로운 오브젝트를 만들게 했다.

덕분에 인스턴스 변수도 부담 없이 사용할 수 있다.

어차피 다음 테스트 메소드가 실행될 때는 새로운 오브젝트가 만들어져서 다 초기화될 것이다.

테스트 메소드의 일부에서만 공통적으로 사용되는 코드가 있다면 어떻게 해야 할까?

이때는 @Before를 사용하기보다는, 일반적인 메소드 추출 방법을 써서 메소드를 분리하고 테스트 메소드에서 직접 호출해 사용하도록 만드는 편이 낫다.

아니면 아예 공통적인 특징을 지닌 테스트 메소드를 모아서 별도의 테스트 클래스로 만드는 방법도 생각해볼 수 있다.

## 테스트 코드 개선 - 픽스처

테스트를 수행하는 데 필요한 정보나 오브젝트를 '픽스처(fixture)'라고 한다.

일반적으로 픽스처는 여러 테스트에서 반복적으로 사용되기 때문에 @Before 메소드를 이용해 생성해두면 편리하다.

## 스프링 테스트 적용

@Before 메소드가 테스트 메소드 개수만큼 반복되기 때문에 애플리케이션 컨텍스트도 세 번 만들어진다.

지금은 설정도 간단하고 빈도 몇 개 없어서 별문제 아닌 듯하지만, 빈이 많아지고 복잡해지면 애플리케이션 컨텍스트 생성에 적지 않은 시간이 걸릴 수 있다.

애플리케이션 컨텍스트가 만들어질 때는 모든 싱글톤 빈 오브젝트를 초기화한다.

단순히 빈 오브젝트를 만드는 정도라면 상관없지만, 어떤 빈은 오브젝트가 생성될 때 자체적인 초기화 작업을 진행해서 제법 많은 시간을 필요로 하기 때문이다.

또 한 가지 문제는 애플리케이션 컨텍스트가 초기화될 때 어떤 빈은 독자적으로 많은 리소스를 할당하거나 독립적인 스레드를 띄우기도 한다는 점이다.

이런 경우에는 테스트를 마칠 때마다 애플리케이션 컨텍스트 내의 빈이 할당한 리소스 등을 깔끔하게 정리해주지 않으면 다음 테스트에서 새로운 애플리케이션 컨텍스트가 만들어지면서 문제를 일으킬 수도 있다.

테스트는 가능한 한 독립적으로 매번 새로운 오브젝트를 만들어서 사용하는 것이 원칙이다.

하지만 애플리케이션 컨텍스트처럼 생성에 많은 시간과 자원이 소모되는 경우에는 테스트 전체가 공유하는 오브젝트를 만들기도 한다.

이때도 테스트는 일관성 있는 실행 결과를 보장해야 하고, 테스트의 실행 순서가 결과에 영향을 미치지 않아야 한다.

문제는 JUnit이 매번 테스트 클래스의 오브젝트를 새로 만든다는 점이다.

따라서 여러 테스트가 함께 참조할 애플리케이션 컨텍스트를 오브젝트 레벨에 저장해두면 곤란하다.

그렇다면 스태틱 필드에 애플리케이션 컨텍스트를 저장해두면 어떨까?

JUnit은 테스트 클래스 전체에 걸쳐 딱 한 번만 실행되는 @BeforeClass 스태틱 메소드를 지원한다.

이 메소드에서 애플리케이션 컨텍스트를 만들어 스태틱 변수에 저장해두고 테스트 메소드에서 사용하게 할 수 있다.

하지만 이보다는 스프링이 직접 제공하는 애플리케이션 컨텍스트 테스트 지원 기능을 사용하는 것이 더 편리하다.

## 스프링 테스트 적용 - 테스트를 위한 애플리케이션 컨텍스트 관리

스프링은 JUnit을 이용하는 테스트 컨텍스트 프레임워크를 제공한다.

테스트 컨텍스트의 지원을 받으면 간단한 어노테이션 설정만으로 테스트에서 필요로 하는 애플리케이션 컨텍스트를 만들어서 모든 테스트가 공유하게 할 수 있다.

### 스프링 테스트 컨텍스트 프레임워크 적용

#### 스프링 테스트 컨텍스트를 적용한 UserDaoTest

```java
@RunWith(SpringJUnit4ClassRunner.class) // 스프링의 테스트 컨텍스트 프레임워크의 JUnit 확장기능 지정
@ContextConfiguration(locations="/applicationContext.xml") // 테스트 컨텍스트가 자동으로 만들어줄 애플리케이션 컨텍스트의 위치 지정
public class UserDaoTest {
  @Autowired
  private ApplicationContext context; // 테스트 오브젝트가 만들어지고 나면 스프링 테스트 컨텍스트에 의해 자동으로 값이 주입된다.

  @Before
  ...
}
```

@RunWith는 JUnit 프레임워크의 테스트 실행 방법을 확장할 때 사용하는 어노테이션이다.

SpringJUnit4ClassRunner라는 JUnit용 테스트 컨텍스트 프레임워크 확장 클래스를 지정해주면 JUnit이 테스트를 진행하는 중에 테스트가 사용할 애플리케이션 컨텍스트를 만들고 관리하는 작업을 진행해준다.

@ContextConfiguration은 자동으로 만들어줄 애플리케이션 컨텍스트의 설정파일 위치를 지정한 것이다.

### 테스트 메소드의 컨텍스트 공유

#### 확인용 코드 추가

```java
@Before
public void setUp() {
  System.out.println(this.context);
  System.out.println(this);
}
```
```java
org.springframework.context.support.GenericApplicationContext@d3d6f:
springbook.dao.UserDaoTest@115d06c
org.springframework.context.support.GenericApplicationContext@d3d6f:
springbook.dao.UserDaoTest@1163118b
org.springframework.context.support.GenericApplicationContext@d3d6f:
springbook.dao.UserDaoTest@15e0c2b
```

출력된 context와 this의 오브젝트 값을 잘 살펴보면, context는 세 번 모두 동일하다.

따라서 하나의 애플리케이션 컨텍스트가 만들어져 모든 테스트 메소드에서 사용되고 있음을 알 수 있다.

반면에 UserDaoTest의 오브젝튼는 매번 주소 값이 다르다.

앞에서 설명한 것처럼 JUnit은 테스트 메소드를 실행할 때마다 새로운 테스트 오브젝트를 만들기 때문이다.

그렇다면 context 변수에 어떻게 애플리케이션 컨텍스트가 들어 있는 것일까?

스프링의 JUnit 확장기능은 테스트가 실행되기 전에 딱 한 번만 애플리케이션 컨텍스트를 만들어두고, 테스트 오브젝트가 만들어질 때마다 특별한 방법을 이용해 애플리케이션 컨텍스트 자신을 테스트 오브젝트의 특정 필드에 주입해주는 것이다.

첫번째 테스트가 실행될 때 최초로 애플리케이션 컨텍스트가 처음 만들어지면서 가장 오랜 시간이 소모되고, 그 다음부터는 이미 만들어진 애플리케이션 컨텍스트를 재사용할 수 있기 때문에 테스트 실행 시간이 매우 짧아지는 것이다.

이렇게 해서 하나의 테스트 클래스 내의 테스트 메소드는 같은 애플리케이션 컨텍스트를 공유해서 사용할 수 있음을 확인했다.

### 테스트 클래스의 컨텍스트 공유

여러 개의 테스트 클래스가 있는데 모두 같은 설정파일을 가진 애플리케이션 컨텍스트를 사용한다면, 스프링은 테스트 클래스 사이에서도 애플리케이션 컨텍스트를 공유하게 해준다.

다음과 같이 두 개의 테스트 클래스가 같은 설정파일을 사용하는 경우에는 테스트 수행 중에 단 한 개의 애플리케이션 컨텍스트만 만들어진다.

두 테스트 클래스의 모든 메소드가 하나의 애플리케이션 컨텍스트를 공유하게 되는 것이다.

```java
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations="/applicationContext.xml")
public class UserDaoTest { .. }

@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations="/applicationContext.xml")
public class GroupDaoTest { .. }
```

위의 ContextConfiguration 어노테이션에 적힌 applicationContext.xml은 공유된다.

따라서 수백 개의 테스트 클래스를 만들었는데 모두 같은 설정파일을 사용한다고 해도 테스트 전체에 걸쳐 단 한개의 애플리케이션 컨텍스트만 만들어져 사용된다.

이 덕분에 테스트 성능이 대폭 향상됨은 더 설명할 필요도 없을 것이다.

### @Autowired

@Autowired는 스프링의 DI에 사용되는 특별한 어노테이션이다.

@Autowired가 붙은 인스턴스 변수가 있으면, 테스트 컨텍스트 프레임워크는 변수 타입과 일치하는 컨텍스트 내의 빈을 찾는다.

타입이 일치하는 빈이 있으면 인스턴스 변수에 주입해준다.

일반적으로는 주입을 위해서는 생성자나 수정자 메소드 같은 메소드가 필요하지만, 이 경우에는 메소드가 없어도 주입이 가능하다.

또 별도의 DI 설정 없이 필드의 타입정보를 이용해 빈을 자동으로 가져올 수 있는데, 이런 방법을 타입에 의한 자동와이어링이라고 한다.

앞에서 만든 테스트 코드에서는 applicationContext.xml 파일에 정의된 빈이 아니라, ApplicationContext라는 타입의 변수에 @Autowired를 붙였는데 애플리케이션 컨텍스트가 DI됐다.

스프링 애플리케이션 컨텍스트는 초기화할 때 자기 자신도 빈으로 등록한다.

따라서 애플리케이션 컨텍스트에는 ApplicationContext 타입의 빈이 존재하는 셈이고 DI도 가능한 것이다.

#### UserDao를 직접 DI 받도록 만든 테스트
```java
...

public class UserDaoTest {
  @Autowired
  UserDao dao;
}
```

@Autowired를 지정하기만 하면 어떤 빈이든 다 가져올 수 있다.

XML에 dataSource라는 이름으로 등록한 SimpleDriverDataSource 타입의 빈을 가져오고 싶다면, 다음 코드처럼 인스턴스 변수를 추가해주기만 하면 된다.

```java
@Autowired
SimpleDriverDataSource dataSource;
```

@Autowired는 변수에 할당 가능한 타입을 가진 빈을 자동으로 찾는다.

단, @Autowired는 같은 타입의 빈이 두 개 이상 있는 경우에는 타입만으로는 어떤 빈을 가져올지 결정할 수 없다.

@Autowired는 타입으로 가져올 빈 하나를 선택할 수 없는 경우에는 변수의 이름과 같은 이름의 빈이 있는지 확인한다.

DataSource 타입의 빈이 두 개 있는데, 하나는 dataSource이고 다른 하나는 dataSource2라면 첫 번째 빈이 주입될 것이다.

변수 이름으로도 빈을 찾을 수 없는 경우에는 예외가 발생한다.

그런데 SimpleDriverDataSource 타입의 변수로 선언하는 방법과 DataSource 타입으로 선언하는 방법 중 어떤 것이 나을까?

그건 테스트에서 빈을 어떤 용도로 사용하느냐에 따라 다르다.

단순히 DataSource에 정의된 메소드를 테스트에서 사용하고 싶은 경우라면 DataSource 타입으로 받는게 좋다.

DataSource로 선언해두면 dataSource 빈의 구현 클래스를 변경하더라도 테스트 코드를 수정할 필요가 없다.

개발자가 만드는 테스트는 코드 내부구조와 설정 등을 알고 있고 의도적으로 그 내용을 검증해야 할 필요가 있기 때문이다.

하지만 꼭 필요하지 않다면 테스트에서도 가능한 한 인터페이스를 사용해서 애플리케이션 코드와 느슨하게 연결해두는 편이 좋다.

## DI와 테스트

인터페이스를 두고 DI를 적용해야 하는 이유이다.

#### 첫째, 소프트웨어 개발에서 절대로 바뀌지 않는 것은 없기 때문이다.
당장에는 클래스를 바꿔서 사용할 계획이 전혀 없더라도, 언젠가 변경이 필요한 상황이 닥쳤을 때 수정에 들어가는 시간과 비용의 부담을 줄여줄 수 있다면, 인터페이스를 사용하고 DI를 적용하는 작은 수고를 하지 않을 이유가 없다.

#### 둘째, 클래스의 구현 방식은 바뀌지 않는다고 하더라도 인터페이스를 두고 DI를 적용하게 해두면 다른 차원의 서비스 기능을 도입할 수 있기 때문이다.

#### 셋째, 테스트 때문이다.
단지 효율적인 테스트를 손쉽게 만들기 위해서라도 DI를 적용해야 한다.

테스트를 잘 활용하려면 자동으로 실행 가능하며 빠르게 동작하도록 테스트 코드를 만들어야 한다.

그러기 위해서는 가능한 한 작은 단위의 대상에 국한해서 테스트해야 한다.

테스트할 대상의 범위가 넓어지면 테스트를 작성하기가 어려워진다.

## DI와 테스트 - 테스트 코드에 의한 DI

#### 테스트를 위한 수동 DI를 적용한 UserDaoTest
```java
@DirtiesContext // 테스트 메소드에서 애플리케이션 컨텍스트의 구성이나 상태를 변경한다는 것을 테스트 컨텍스트 프레임워크에서 알려준다.
public class USerDaoTest {
  @Autowired
  UserDao dao;

  @Before
  public void setUp() {
    ...
    DataSource dataSource = new SingleConnectionDataSource("jdbc:mysql://localhost/testdb", "spring", "book", true);

    dao.setDataSource(dataSource);
  }
}
```

이 방법의 장점은 XML 설정파일을 수정하지 않고도 테스트 코드를 통해 오브젝트 관계를 재구성할 수 있다는 것이다.

예외적인 상황을 만들기 위해 일부러 엉뚱한 오브젝트를 넣거나, 위와 같은 테스트용으로 준비된 오브젝트를 사용하게 할 수 있다.

하지만 이 방식은 매우 주의해서 사용해야 한다.

이미 애플리케이션 컨텍스트에서 applicationContext.xml 파일의 설정정보를 따라 구성한 오브젝트를 가져와 의존관계를 강제로 변경했기 때문이다.

스프링 테스트 컨텍스트 프레임워크를 적용했다면 애플리케이션 컨텍스트는 테스트 중에 딱 한 개만 만들어지고 모든 테스트에서 공유해서 사용한다.

따라서 애플리케이션 컨텍스트의 구성이나 상태를 테스트 내에서 변경하지 않는 것이 원칙이다.

@DirtiesContext라는 어노테이션을 추가해줬다.

이 어노테이션은 스프링의 테스트 컨텍스트 프레임워크에게 해당 클래스의 테스트에서 애플리케이션 컨텍스트의 상태를 변경한다는 것을 알려준다.

테스트 컨텍스트는 이 어노테이션이 붙은 테스트 클래스에는 애플리케이션 컨텍스트 공유를 허용하지 않는다.

테스트 메소드를 수행하고 나면 매번 새로운 애플리케이션 컨텍스트를 만들어서 다음 테스트가 사용하게 해준다.

테스트 중에 변경한 컨텍스트가 뒤의 테스트에 영향을 주지 않게 하기 위해서다.

## DI와 테스트 - 테스트를 위한 별도의 DI 설정

테스트 코드에서 빈 오브젝트에 수동으로 DI 하는 방법은 장점보다 단점이 많다.

코드가 많아져 번거롭기도 하고 애플리케이션 컨텍스트도 매번 새로 만들어야 하는 부담이 있다.

이 방법 외에 DI의 장점을 살려서 DAO가 테스트에서만 다른 DataSource를 사용하게 할 수 있는 방법이 또 있을까?

아예 테스트에서 사용될 DataSource 클래스가 빈으로 정의된 테스트 전용 설정파일을 따로 만들어두는 방법을 이용해도 된다.

즉 두 가지 종류의 설정파일을 따로 만들어두는 방법을 이용해도 된다.

즉 두 가지 종류의 설정파일을 만들어서 하나의 서버에서 운영용으로 사용할 DataSource를 빈으로 등록해두고, 다른 하나에는 테스트에 적합하게 준비된 DB를 사용하는 가벼운 DataSource가 빈으로 등록되게 만드는 것이다.

그리고 테스트에서는 항상 테스트 전용 설정파일만 사용하게 해주면 된다.

먼저 기존의 applicationContext.xml 을 복사해서 test-applicationContext.xml 만든다.

#### 테스트 DB 변경 설정
```
<bean id="dataSource"
  ...
  <property name="url" value="jdbc:mysql://localhost/testdb" />
</bean>
```

나머지 테스트 코드는 수정하지 않아도 된다.

번거롭게 수동 DI 하는 코드나 @DirtiesContext도 필요 없다.

#### 테스트용 설정 파일 적용
```java
@Runwith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations="/test-applicationContext.xml")
public class UserDaoTest {
```

## DI와 테스트 - 컨테이너 없는 DI 테스트

DI를 테스트에 이용하는 방법은 아예 스프링 컨테이너를 사용하지 않고 테스트를 만드는 것이다.

구현 클래스 어디에도 스프링의 API를 직접 사용한다거나 의존하지 않는다는 말이다.

따라서 원한다면 스프링 컨테이너를 이용해서 IoC 방식으로 생성되고 DI 되도록 하는 대신, 테스트 코드에서 직접 오브젝트를 만들고 DI 해서 사용해도 된다.

애플리케이션 컨텍스트가 만들어지는 번거로움이 없어졌으니 그만큼 테스트시간도 절약할 수 있다.

하지만 JUnit은 매번 새로운 테스트 오브젝트를 만들기 때문에 매번 새로운 UserDao 오브젝트가 만들어진다는 단점도 있다.

UserDao가 스프링의 API에 의존하지 않고 자신의 관점에만 집중해서 깔끔하게 만들어진 코드이기 때문에 가능한 일이다.

바로 이런 가볍고 깔끔한 테스트를 만들 수 있는 이유도 DI를 적용했기 때문이다.

DI는 객체지향 프로그래밍 스타일이다.

따라서 DI를 위해 컨테이너가 반드시 필요한 것은 아니다.

DI 컨테이너나 프레임워크는 DI를 편하게 적용하도록 도움을 줄 뿐, 컨테이너가 DI를 가능하게 해주는 것은 아니다.

DI가 적용된 코드는 테스트에서도 다양한 방식으로 활용할 수 있을 만큼 유연하다.

어디에 DI를 적용할지 고민되는 경우, 효과적인 테스트를 만들기 위해서는 어떤 필요가 있을지를 생각해보면 도움이 된다.

두 개의 모듈이 강하게 결합되어 있어 DI가 불가능한 구조로 만든다면 테스트할 때 불편해진다거나, 자동화된 테스트가 아예 불가능하지 않을까 의심해야한다.

일반적으로 테스트하기 좋은 코드가 좋은 코드일 가능성이 높다.

## DI와 테스트 - DI를 이용한 테스트 방법 선택
DI를 테스트에 이용하는 세 가지 방법 중 어떤 것을 선택해야 할까?

항상 스프링 컨테이너 없이 테스트할 수 있는 방법을 가장 우선적으로 고려하자.

이 방법이 테스트 수행 속도가 가장 빠르고 테스트 자체가 간결하다.

테스트를 위해 필요한 오브젝트의 생성과 초기화가 단순하다면 이 방법을 가장 먼저 고려해야 한다.

여러 오브젝트와 복잡한 의존관계를 갖고 있는 오브젝트를 테스트해야 할 경우가 있다.

이때는 스프링의 설정을 이용한 DI 방식의 테스트를 이용하면 편리하다.

테스트에서 애플리케이션 컨텍스트를 사용하는 경우에는 테스트 전용 설정파일을 따로 만들어 사용하는 편이 좋다.

보통 개발환경, 테스트환경, 운영환경이 차이가 있기 때문에 각각 다른 설정파일을 만들어 사용하는 경우가 일반적이다.

테스트 설정을 따로 만들었다고 하더라도 때로는 예외적인 의존관계를 강제로 구성해서 테스트해야 할 경우가 있다.

이때는 컨텍스트에서 DI 받은 오브젝트에 다시 테스트 코드로 수동 DI 해서 테스트하는 방법을 사용하면 된다.

테스트 메소드나 클래스에 @DirtiesContext 어노테이션을 붙이는 것을 잊지 말자

## 정리

- 테스트는 자동화돼야 하고, 빠르게 실행할 수 있어야 한다.
- main() 테스트 대신 JUnit 프레임워크를 이용한 테스트 작성이 편리하다.
- 테스트 결과는 일관성이 있어야 한다. 코드의 변경 없이 환경이나 테스트 실행 순서에 따라서 결과가 달라지면 안 된다.
- 테스트는 포괄적으로 작성해야 한다. 충분한 검증을 하지 않는 테스트는 없는 것보다 나쁠 수 있다.
- 코드 작성과 테스트 수행의 간격이 짧을수록 효과적이다.
- 테스트하기 쉬운 코드가 좋은 코드다
- 테스트를 먼저 만들고 테스트를 성공시키는 코드를 만들어가는 테스트 주도 개발 방법도 유용하다.
- 테스트 코드도 애플리케이션 코드와 마찬가지로 적절한 리팩토링이 필요하다.
- @Before, @After를 사용해서 테스트 메소드들의 공통 준비 작업과 정리 작업을 처리할 수 있다.
- 스프링 테스트 컨텍스트 프레임워크를 이용하면 테스트 성능을 향상시킬 수 있다.
- 동일한 설정파일을 사용하는 테스트는 하나의 애플리케이션 컨텍스트를 공유한다.
- @Autowired를 사용하면 컨텍스트의 빈을 테스트 오브젝트에 DI 할 수 있다.
- 기술의 사용 방법을 익히고 이해를 돕기 위해 학습 테스트를 작성하자
- 오류가 발견될 경우 그에 대한 버그 테스트를 만들어두면 유용하다.

스프링을 사용하는 개발자라면 자신이 만든 코드를 테스트로 검증하는 방법을 알고 있어야 하며, 테스트를 개발에 적극적으로 활용할 수 있어야 한다.


























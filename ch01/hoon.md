## 개요

### 스프링 개요

#### 애플리케이션의 기본 틀 - 스프링 컨테이너

스프링 런타임 엔진 제공 : 스프링 컨테이너 또는 애플리케이션 컨테이너 런타임 엔진 제공 → 스프링 컨테이너는 설정 정보를 참고해서 애플리케이션을 구성하는 오브젝트를 생성하고 관리한다.

#### 공통 프로그래밍 모듈

-   IoC/ DI : 오브젝트 생명주기와 의존관계에 대한 프로그래밍 모델
-   서비스 추상화 : 구체적인 기술과 환경에 종속되지 않도록 유연한 추상 계층을 두는 방식
-   AOP : 애플리케이션 코드에 산재된 횡단 관심사를 독립적으로 모듈화하는 프로그래밍 모델

---

## 1장 : 오브젝트와 의존 관계

### 1.1 초난감 DAO(문제가 많은, 난감한 DAO……..)

**알고 있어야 할 개념**

-   DAO : DB를 사용해 데이터를 조회하거나 조작하는 기능을 전담하도록 만든 오브젝트
-   자바빈이 되기 위한 조건:
    -   파라미터가 없는 디폴트 생성자를 가져야 함.
    -   빈의 프로퍼티는 getter와 setter를 통해서 접근할 수 있어야 함.

**초난감 DAO 예시**

```
리스트 1-2 JDBC를 이용한 등록과 조회 기능이 있는 UserDao 클래스

함수 add(사용자)
    데이터베이스 드라이버 로딩
    데이터베이스 연결 생성 (DB 주소, 사용자명, 비밀번호로)

    SQL 문 준비: "INSERT INTO users(id, name, password) VALUES (?, ?, ?)"
    첫 번째 파라미터에 사용자 ID 설정
    두 번째 파라미터에 사용자 이름 설정
    세 번째 파라미터에 사용자 비밀번호 설정

    SQL 실행 (데이터 삽입)

    SQL 자원 및 연결 종료
끝

함수 get(사용자 ID)
    데이터베이스 드라이버 로딩
    데이터베이스 연결 생성 (DB 주소, 사용자명, 비밀번호로)

    SQL 문 준비: "SELECT * FROM users WHERE id = ?"
    첫 번째 파라미터에 사용자 ID 설정

    SQL 실행 (데이터 조회)
    결과에서 다음 행으로 이동

    사용자 객체 생성
    사용자 ID를 결과에서 가져와 설정
    사용자 이름을 결과에서 가져와 설정
    사용자 비밀번호를 결과에서 가져와 설정

    SQL 자원 및 연결 종료

    사용자 객체 반환
끝
```

책의 자바 코드를 의사코드로 옮겨서 단순화되었지만, DB 드라이버 로딩, 연경 생성,SQL 실행 등 중복된 기능을 하는 메서드가 DAO 코드에 흩어져있다.(난감….)

### 1.2 DAO의 분리

#### 1.2.1 관심사의 분리

애플리케이션 오브젝트에 대한 설계와 코드는 계속 변한다. 언제든 변화에 대비할 수 있도록 “분리와 확장”을 고려하여 설계해야 한다.

프로그래밍 기초 개념 중 “관심사의 분리” 개념을 적용하여 응집도를 높이는 설계가 중요하다.

#### 1.2.2 커넥션 만들기의 추출

난감한 DAO 코드의 관심 사항(동작을 하는 단위)을 추출해보면,

```
함수 add(사용자)
    데이터베이스 드라이버 로딩
    데이터베이스 연결 생성 (DB 주소, 사용자명, 비밀번호로)

    SQL 문 준비: "INSERT INTO users(id, name, password) VALUES (?, ?, ?)"
    첫 번째 파라미터에 사용자 ID 설정
    두 번째 파라미터에 사용자 이름 설정
    세 번째 파라미터에 사용자 비밀번호 설정

    SQL 실행 (데이터 삽입)

    SQL 자원 및 연결 종료
끝

함수 get(사용자 ID)
    데이터베이스 드라이버 로딩
    데이터베이스 연결 생성 (DB 주소, 사용자명, 비밀번호로)

    SQL 문 준비: "SELECT * FROM users WHERE id = ?"
    첫 번째 파라미터에 사용자 ID 설정

    SQL 실행 (데이터 조회)
    결과에서 다음 행으로 이동

    사용자 객체 생성
    사용자 ID를 결과에서 가져와 설정
    사용자 이름을 결과에서 가져와 설정
    사용자 비밀번호를 결과에서 가져와 설정

    SQL 자원 및 연결 종료

    사용자 객체 반환
끝
```

1.  DB Connection
2.  SQL 준비 및 실행
3.  자원 반납

의 3가지로 추출해 볼 수 있다.

[##_Image|kage@QCXq7/btsOmppz7Kp/9gbfTBAE5NEPnnQhcM7ZHk/img.png|CDM|1.3|{"originWidth":934,"originHeight":654,"style":"alignCenter","width":714,"height":500}_##]

add, get 함수에 산재되어 있는 중복된 코드를 분리하여 코드의 가독성을 높이고, 함수의 응집도를 높일 수 있다.

#### 1.2.3 DB 커넥션 만들기의 독립

만약, UserDao를 판매한다고 가정해보자. UserDao의 소스코드를 공개하지 않고 각 고객(고객사)에서 각자의 환경에 맞춰 getConnection() 을 수정하여 사용할 수 있도록 하고 싶어서 컴파일된 클래스 바이너리 파일만을 제공한다고 했을 때 getConnection() 메서드의 수정 가능성을 보장할 수 있을까?

**상속을 통한 확장**

기존 DAO 코드에서 한 단계 더 분리하여 getConnection()의 구현 코드를 제거하고 추상 메서드로 변경하면 된다.

<img width="442" alt="Image" src="https://github.com/user-attachments/assets/61a264bb-ed58-4a6f-9022-38cf42176dee" />

UserDao를 상속하여 고객사에 맞는 DAO 클래스를 생성하여 getConnection() 메서드를 구현할 수 있다.

<img width="441" alt="Image" src="https://github.com/user-attachments/assets/d84dd944-a672-482f-abfe-2cf0b9a1ac77" />

이렇게 슈퍼 클래스에 기본적인 로직의 흐름(커넥션 가져오기, SQL 생성·실행·반환)을 만들고, 그 기능의 일부를 추상 메서드나 오버라이딩이 가능한 protected 메서드 등으로 만들어, 서브 클래스에서 이런 메서드를 필요에 맞게 구현해 사용하도록 하는 방법을 디자인 패턴에서 "템플릿 메서드 패턴"이라고 한다.

### 1.3 DAO의 확장

#### 1.3.2 인터페이스의 도입

인터페이스는 어떤 일을 하겠다는 기능만 정의해놓은 것이다. 따라서 인터페이스에는 어떻게 하겠다는 구현 방법은 나타나 있지 않으며, 인터페이스를 구현한 클래스들이 알아서 결정할 일이다.

어떤 객체가 인터페이스를 사용하게 한다면 인터페이스의 메서드를 통해 알 수 있는 기능에만 관심을 가지면 되지, 그 기능을 어떻게 구현했는지에 대해서는 알 필요가 없다.

#### 1.3.4 원칙과 패턴

**"개방 폐쇄 원칙(OCP, Open-Closed Principle)"**

클래스나 모듈은 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다.

UserDao 사례에서 DB 연결 방법이라는 기능을 확장하는 데는 열려있다.(분리되어 있어서 DB 연결 방법을 바꾸어도 DAO의 동작에는 영향을 미치지 않는다.)

SOLID 원칙으로 정의되는 5가지 원칙은 다음과 같다.

\- 단일 책임 원칙(SRP, Single Responsibility Principle)

\- 개방 폐쇄 원칙(OCP, Open Closed Principle)

\- 리스코프 치환 원칙(LSP, Liskov Subsitution Principle)

\- 인터페이스 분리 원칙(ISP, Interface Segregration Principle)

\- 의존관계 역전 원칙(Dependency Inversion Principle)

 **"높은 응집도와 낮은 결합도"**

"응집도"

응집도란 \[모듈의 독립성을 나타내는 개념으로, 모듈 내부 구성요소 간 연관 정도\]를 뜻한다.

응집도가 높다는 건 하나의 모듈, 클래스가 하나의 책임 또는 관심사에만 집중되어 있다는 뜻이다. 불필요하거나 직접 관련이 없는 외부의 관심과 책임이 얽혀 있지 않으며, 하나의 공통 관심사는 한 클래스에 모여 있다.

예제와 같이 인터페이스를 이용해 DB 연결 기능을 독립시킨 경우가 높은 응집도를 위해 적절하게 리펙토링 한 경우가 될 수 있다.

"결합도"

결합도란 \[결합도는 모듈 내부가 아닌 외부의 모듈과의 연관도 또는 모듈 간의 상호의존성을 나타내는 정도\]를 뜻한다.

이러한 결합도를 낮게(느슨하게) 유지하는 것이 중요한데, 책임과 관심사가 다른 오브젝트 또는 모듈끼리 서로 분리되어 수정이나 확장 시 서로 영향을 미치지 않을 수 있도록 할 수 있기 때문이다.예제에서 UserDao와 ConnectionMaker(DB 연결을 위한 클래스)의 관계가 느슨한 연결로 볼 수 있다.

**"전략 패턴"**

전략 패턴은 자신의 기능 맥락에서 필요에 따라 변경이 필요한 알고리즘을 인터페이스를 통해 통째로 외부로 분리시키고, 이를 구현한 구체적인 알고리즘 클래스를 필요에 따라 바꿔서 사용할 수 있게 하는 디자인 패턴이다.

예제에서 UserDao는 전략 패턴의 컨텍스트(특정 알고리즘을 실행하기 위한 객체)에 해당한다.

### 1.4 제어의 역전(IoC)

#### 1.4.1 오브젝트 팩토리

"팩토리"

객체의 생성 방법을 결정하고 그렇게 만들어진 오브젝트를 돌려주는 역할을 한다.(이 예제에서 말하는 팩토리는 추상 팩토리 패턴이나 팩토리 메서드 패턴과는 다름.)

UserDao의 생성 책임을 맡은 팩토리 클래스 예제

```Java

public class DaoFactory {

  public UserDao userDao() {

    ConnectionMaker connMaker = new ConnectionMaker ();

    UserDao dao = new UserDao(connMaker);

  return dao;

  }

}

```

#### 1.4.3 제어권의 이전을 통한 제어관계 역전

사용자가 객체가 사용할 오브젝트를 결정하고, 그 오브젝트를 생성하고, 생성된 오브젝트에 있는 메서드를 호출하고, 그 메서드 안에서 다음에 사용할 것을 결정하고 호출하는 식의 작업이 반복된다.

하지만 제어의 역전이 적용되면 오브젝트가 자신이 사용할 오브젝트를 스스로 선택/생성하지 않는다. 제어 권한을 자신이 아닌 다른 대상에게 위임하기 때문이다.

라이브러리는 사용하는 애플리케이션 코드가 애플리케이션의 흐름을 직접 제어한다.

프레임워크는 애플리케이션 코드가 프레임워크에 의해 사용된다. 개발한 클래스를 등록해두고, 프레임워크가 흐름을 주도하는 중에 개발자가 만든 애플리케이션 코드를 사용하도록 만드는 방식이다.(스프링 빈 등)

### 1.5 스프링의 IoC

#### 1.5.1 오브젝트 팩토리를 이용한 스프링 IoC

**\- 빈(Bean)** : 빈 또는 빈 오브젝트는 스프링이 IoC 방식으로 관리하는 오브젝트.

**\- 빈 팩토리(Bean Factory)** : 빈의 생성과 관계설정 같은 제어를 담당하는 IoC 오브젝트.

**\- 애플리케이션 컨텍스트(Application Context)** : 빈 팩토리를 확장한, IoC 방식을 따라 만들어진 빈 팩토리의 일종. 별도의 정보를 참고해서 빈의 생성, 관계 설정 등의 제어 작업을 총괄함.

\- 컨테이너(Container) 또는 IoC 컨테이너 : IoC 방식으로 빈을 관리한다는 의미에서 애플리케이션 컨텍스트나 빈 팩토리를 컨테이너 또는 IoC 컨테이너라고 부름.

#### 1.5.2 애플리케이션 컨텍스트의 동작방식

애플리케이션 컨텍스트는 ApplicationContext 인터페이스를 구현하는데, ApplicationContext는  빈 팩토리가 구현하는 BeanFactory 인터페이스를 상속했으므로 애플리케이션 컨텍스트는 일종의 빈 팩토리이다.

-   SpringApplication.run()을 통해 ApplicationContext가 생성
-   ApplicationContext는 내부적으로 BeanFactory를 사용해 빈 정의를 로딩
-   이후 각 빈을 순차적으로 생성하며, 의존성 주입과 초기화를 수행
-   모든 빈이 초기화되면 사용자 애플리케이션이 실행을 시작할 준비 완료

<img width="616" alt="Image" src="https://github.com/user-attachments/assets/bda25864-b3d8-4c60-912a-e507ccfa6b16" />

```
sequenceDiagram
    participant UserApp as 사용자 애플리케이션
    participant SpringBoot as SpringApplication.run()
    participant Ctx as ApplicationContext
    participant BeanFactory as BeanFactory
    participant Bean as @Component 등 빈 객체

    UserApp->>SpringBoot: 애플리케이션 시작
    SpringBoot->>Ctx: ApplicationContext 생성
    Ctx->>BeanFactory: 빈 정의 로드 (XML, @Configuration, @ComponentScan 등)
    BeanFactory-->>Ctx: 빈 정의 완료

    loop 빈 초기화 과정
        Ctx->>BeanFactory: 빈 인스턴스 요청
        BeanFactory->>Bean: 빈 생성자 호출
        Bean-->>BeanFactory: 빈 생성 완료
        BeanFactory->>Bean: 의존성 주입 (@Autowired 등)
        BeanFactory->>Bean: 초기화 콜백 (InitializingBean, @PostConstruct)
        Bean-->>BeanFactory: 초기화 완료
        BeanFactory-->>Ctx: 초기화된 빈 반환
    end

    SpringBoot-->>UserApp: 실행 완료, 서비스 준비됨
```

오브젝트 팩토리로 직접 사용했을 때와 비교해서 애플리케이션 컨텍스트를 사용했을 때 얻을 수 있는 장점은 다음과 같다.

\- 클라이언트는 구체적인 팩토리 클래스를 알 필요가 없다

\- 애플리케이션 컨텍스트는 종합 IoC 서비스를 제공해준다

\- 애플리케이션 컨텍스트는 빈을 검색하는 다양한 방법을 제공한다

### 1.6 싱글톤 레지스트리와 오브젝트 스코프

"오브젝트의 동일성과 동등성"

동일한(identical) 오브젝트라고 부르는 것과 동일한 정보를 담고 있는(equivalent) 오브젝트라고 부르는 것은 차이가 있음.

동일성은 == 연산자로, 동등성은 equals() 메서드를 이용해서 비교함.

동일하다는 것 : 하나의 오브젝트만 존재하고 여러 개의 오브젝트 레퍼런스 변수가 존재하는 것.

동일하지는 않지만 동등한 경우 : 여러 개의 각기 다른 오브젝트가 메모리 상에 존재하지만 동등성 기준에 따라 두 오브젝트의 정보가 동등하다고 판단하는 것.

#### 1.6.1 싱글톤 레지스트리로서의 애플리케이션 컨텍스트

스프링은 별다른 설정을 하지 않으면 내부에서 생성하는 빈 오브젝트를 모두 싱글톤으로 만든다.

"싱글톤 패턴의 한계"

자바에서 싱글톤을 구현하는 방법

\- 클래스 밖에서 오브젝트를 생성하지 못하도록 생성자를 private으로 만든다.

\- 생성된 싱글톤 오브젝트를 저장할 수 있는 자신과 같은 타입의 static 필드를 정의한다.

\- static 팩토리 메서드인 getInstance()를 만들고 이 메서드가 최초로 호출되는 시점에서 한벙만 오브젝트가 만들어지게 한다.

\- 싱글톤 오브젝트가 만들어지고 난 후에는 getInstance() 메서드를 통해 이미 만들어져 static 필드에 저장해둔 오브젝트를 넘겨준다.

따라서 파생되는 문제점은 다음과 같다.

\- private 생성자를 갖고 있기 때문에 상속할 수 없다.

\- 싱글톤은 테스트하기 어렵다.

\- 서버환경에서 싱글톤이 하나만 만들어지는 것을 보장하지 못한다.

\- 싱글톤의 사용은 전역 산태를 만들 수 있기 때문에 바람직하지 못하다.

"싱글톤 레지스트리"

스프링에서는 싱글톤 레지스트리를 통해 직접 싱글톤 형태의 오브젝트를 만들고 관리하는 기능을 제공한다.

따라서 스프링은 IoC 컨테이너일 뿐만 아니라, 싱글톤을 만들고 관리해주는 싱글톤 레지스트리가 될 수 있다.

#### 1.6.2 싱글톤과 오브젝트의 상태

기본적으로 싱글톤이 멀티스레드 환경에서 서비스 형태의 오브젝트로 사용되는 경우에는 상태정보를 내부에 갖고 있지 않은 무상태 방식으로 만들어져야 한다.

### 1.7 의존관계 주입(DI)

#### 1.7.1 제어의 역전(IoC)와 의존관계 주입(DI)

IoC : 객체의 생성과 관리를 개발자가 하는 것이 아니라 프레임워크가 대신 하는 것

DI : 외부에서 객체를 주입받아 사용하는 것

#### 1.7.2 런타임 의존관계 설정

인터페이스를 통해 설계 시점에 느슨한 의존관계를 갖는 경우에는 특정 오브젝트가 런타임 시 사용할 오브젝트가 어떤 클래스로 만든 것인지 미리 알 수 없다. 즉, 개발자나 운영자가 사전에 어떤 클래스의 오브젝트를 쓸지 미리 정해놓을 수는 있지만 그것이 실제 코드 속에서는 드러나지 않는다.

프로그램이 시작되고, 어떤 오브젝트가 만들어지고 나서 런타임 시 의존관계를 맺는 대상(실제 사용대상인 오브젝트)를 의존 오브젝트(dependent object)라고 한다.

의존관계 주입은 다음의 3가지 조건을 충족해야 한다.

1\. 클래스 모델이나 코드에는 런타임 시점의 의존관계가 드러나지 않는다. 그렇기 위해서 인터페이스에만 의존하고 있는 관계가 되어야 한다.

2\. 런타임 시점의 의존관계는 컨테이너나 팩토리 같은 제 3의 존재가 결정한다.(스프링에서는 애플리케이션 컨텍스트, IoC 컨테이너, 빈 팩토리가 제 3의 존재가 된다.)

3\. 의존관계는 사용할 오브젝트에 대한 레퍼런스를 외부에서 제공(주입)해줌으로써 만들어진다.

#### 1.7.3 의존관계 검색과 주입

의존관계를 만들 때 의존관계를 외부에서 주입 받는 것 뿐만 아니라 능동적으로 의존관계를 검색하여 요청하는 방법도 있다. 이를 의존관계 검색(dependency lookup)이라고 한다.

의존관계 검색은 런타임 시 의존관계를 맺을 오브젝트 결정과 생성은 외부 컨테이너에 IoC로 맡기지만, 이를 가져올 때는 스스로 컨테이너에 요청하여 사용한다.

의존관계 검색 예제

```
public UserDao() {
	AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(DaoFactory.class);
	this.connectionMaker = context.getBean "connectionMaker", ConnectionMaker,class);
}
```

대개는 의존관계 주입 방법을 사용하는 것이 좋지만, 의존관계 검색을 사용해야 할 때가 있다.

예를 들어, 테스트 환경의 static 메서드에서는 DI를 통해 의존관계를 주입받기 어렵기 때문에 getBean() 메서드와 같은 의존관계 검색 방식을 통해 애플리케이션 컨텍스트에서 오브젝트를 가져와야 한다.

또한, 스프링 컨테이너에 의해 관리되지 않는 서블릿 등에서 스프링 빈을 사용해야 할 경우, 초기화 시점 등에 의존관계 검색 방식을 통해 오브젝트를 얻어올 수 있다.

의존관계 검색과 주입 방식의 중요한 차이점은, 의존관계 검색 시에는 검색을 요청하는 오브젝트 자체가 반드시 스프링 빈일 필요는 없다는 점이다.

반면, 의존관계 주입 방식에서는 의존관계를 주입받는 오브젝트는 스프링 컨테이너가 관리하는 빈이어야 한다. 이는 컨테이너가 해당 오브젝트의 생성과 의존성 주입을 담당하기 때문이며, 주입되는 대상 역시 일반적으로 빈으로 등록되어 관리되기 때문이다.

\*\*DI를 원하는 오브젝트는 먼저 자기 자신이 컨테이너가 관리하는 빈이 돼야 한다.\*\*

#### 1.7.5 메서드를 이용한 의존관계 주입

1\. 수정자 메서드를 이용한 주입

2\. 일반 메서드를 이용한 주입

3\. XML을 이용한 주입

**XML 코드와 대응되는 Java 코드**

```
@Bean -------------------------------------------------> ‹bean
public ConnectionMaker
connectionMaker() { -----------------------------------> id="connectionMaker"
	return new ConnectionMaker (); -------------------> class="springbook..DConnectionMaker" />
}
```

# 들어가기
## 스프링의 3가지 핵심 프로그래밍 모델
### 1. IoC/DI 오브젝트 생명주기와 의존관계에 대한 프로그래밍 모델
### 2. 서비스 추상화
- 구체적인 기술과 환경에 종속되지 않고 유연한 추상 계층을 두는 방법
### 3. AOP
- 스프링은 AOP를 이용해서 다양한 엔터프라이즈 서비스를 적용하고도 깔끔한 코드를 작성할 수 있게 해준다.

# 1장. 오브젝트와 의존관계
> **DAO(Data Access Object)** : DB를 사용해 데이터를 조회하거나 조작하는 기능을 전담하도록 만든 오브젝트

---

### Q. 변경이 일어났을 때 필요한 작업을 최소화하고 변경된 부분이 다른 곳에 영향이 없게하려면 어떻게 해야할까?
"분리"와 "확장"을 고려한 설계가 있어야 한다.

변화는 대체로 집중된 한가지 관심에 대해 일어나지만 그에 따른 작업은 한 곳에 집중되지 않는게 많다.

변화가 한 번에 한가지 관심에 집중된다면, 관심이 같은 것끼리는 모으고 관심이 다른 것은 따로 떨어져있게 하는 것이다.

프로그래밍 기초 개념 중 "관심사의 분리"가 있다.

이를 객체지향에 적용해보면 관심사가 같은 것끼리는 하나의 객체 안으로 관심사가 다른 것은 따로 떨어져있다.

관심이 다른 것들은 가능한 떨어져서 서로 간 영향을 주지않게 분리한다.

---

> **템플릿 메서드 패턴(Template Method Pattern)** : 슈퍼 클래스에 기본적인 로직의 흐름(Ex. 커넥션 가져오기, SQL 생성, 실행)을 만들고, 그 기능을 추상 메서드나 오버라이딩 가능한 protected 메서드 등으로 만든 뒤 서브 클래스에서 이런 메서드를 필요에 맞게 구현해서 사용하도록 하는 디자인 패턴

> **팩토리 메서드 패턴(Factory Method Pattern)** : 서브클래스에서 구체적인 오브젝트 생성 방법을 결정하는 디자인  패턴

---

### Q. 추상화

두 개의 클래스가 서로 긴말하게 연결되어 있지 않도록 중간에 추상적인 연결고리를 만들어준다.

"추상화"란 어떤 것드리 공통적인 성격을 뽑아내어 이를 따로 분리해주는 작업이다.

-> 자바에서는 인터페이스(interface) 지원

인터페이스는 자신을 구현한 클래스에 대한 구체적인 정보는 모두 감춘다.

---

> **개방 폐쇄 원칙(OCP)** : 클래스나 모듈이 확장에는 열려있고 변경에는 닫혀있어야 한다.

---

> **결합도** : 하나의 오브젝트가 변경이 일어날 때 관계를 맺고있는 다른 오브젝트에게 변화를 요구하는 정보

### Q. 응집도와 결합도

응집도가 높다는 것은 변화가 일어날 때 해당 모듈에서 변하는 부분이 크다는 것이다.

즉, 변경이 일어날 때 모듈의 많은 부분이 함께 바뀐다면 응집도가 높다는 것이다.

낮은 결합도는 높은 응집도보다 더 민감한 원칙이다.

느슨한 연결은 관계를 유지하는데 꼭 필요한 최소한의 방법만 간접적인 형태로 제공하고, 나머지는 서로 독립적이고 알 필요도 없게 만들어주는 것이다.

---

> **전략 패턴** : 자신의 기능 맥락에서 필요에 따라 변경이 필요한 알고리즘을 인터페이스를 통해 통쨰로 외부로 분리시키고, 이를 구현한 구체적인 알고리즘 클래스를 필요에 따라 바꿔서 사용할 수 있게 하는 디자인 패턴

---

### Q. 오브젝트 팩토리(Object Factory)

분리시킬 기능을 담당하는 클래스를 하나 만든다.

이 클래스의 역할은 객체의 생성 방법을 결정하고 그렇게 만들어진 오브젝트를 돌려주는 것인데, 이런 일을 하는 오브젝트를 "오브젝트 팩토리"라고 부른다.

---

### Q. 제어의 역전

제어의 역전은 간단히 프로그램의 제어 흐름 구조가 뒤바뀌는 것이다.

일반적인 프로그램의 흐름은

  1. 프로그램이 시작되는 지점에서 다음에 사용할 오브젝트를 결정하고
  2. 결정한 오브젝트를 생성하고
  3. 만들어진 오브젝트에 있는 메서드를 호출하고
  4. 그 오브젝트 메서드 안에서 다음에 사용할 것들을 결정하고 호출하는 식의 작업이 반복된다.

모든 오브젝트가 능동적으로 자신이 사용할 클래스를 결정하고, 언제 어떻게 그 오브젝트를 만들지 스스로 관장한다.

모든 종류의 작업을 사용하는 쪽에서 제어하는 구조이다.

But! 제어의 역전은 이 모든사항을 거꾸로 뒤집는다.

즉, 제어의 역전에서는 오브젝트가 자신이 사용할 오브젝트를 스스로 선택하지 않는다.

또 생성하지도 않으며 자신도 어떻게 만들어지고 사용되는지 알 수 없다.

그렇기에 모든 제어 권한을 자신이 아닌 다른 대상에게 위임하기 떄문이다.

제어권을 상위 템플릿 메서드에 넘기고 자신은 필요할 때 호출되어 사용되도록 한다는 제어의 역전 개념이다.

### Q. 라이브러리와 프레임워크 차이

라이브러리와 프레임워크의 차이에서도 제어의 역전 사례를 볼 수 있다.

라이브러리는 개발자가 필요한 기능이 있을 시에 능동적으로 사용하지만, 프레임워크는 거꾸로 어플리케이션 코드가 프레임워크의 가이드 라인에 맞춰 사용된다.

이 부분에 따라 프레임워크는 제어의 역전 개념이 분명히 적용되어 있어야한다.

---

> **빈(Bean)** : 스프링이 제어권을 가지고 직접 만들고 관계를 부여하는 오브젝트

> **스프링 빈(Spring Bean)** : 스프링 컨테이너가 생성과 관계설정, 사용 등을 제어해주는 제어의 역전이 적용된 오브젝트

> **빈 팩토리(Bean Factory)** : 스프링에서는 빈의 생성과 관계설정 같은 제어를 담당하는 IoC 오브젝트

---

### Q. 빈 팩토리 vs 어플리케이션 컨텍스트

빈 팩토리는 빈을 생성하고 관계를 설정하는 IoC의 기본 기능에 초점을 맞춘 것이고, 어플리케이션 컨텍스트는 어플리케이션 전반에 걸쳐 모든 구성요소의 제어 작업(별도의 정보를 참고해서 빈의 생성, 관계 설정 등의 제어 작업 총괄)을 담당하는 IoC 엔진이다.

어플리케이션 컨텍스트는 ApplicationContext 인터페이스를 구현하는데, ApplicationContext는 빈 팩토리가 구현하는 BeanFactory 인터페이스를 상속했으므로 어플리케이션 컨텍스트는 일종의 빈 팩토리인 셈이다.

---

### Q. 어플리케이션 컨텍스트를 사용했을 때 얻을 수 있는 장점

#### 1. 클라이언트는 구체적인 팩토리 클래스를 알 필요가 없다.
어플리케이션이 발전하면 IoC를 적용한 오브젝트도 계속 추가될 것이다.

클라이언트가 필요한 오브젝트를 가져오려면 어떤 팩토리 클래스를 사용해야할지 알아야하고, 필요할 때마다 팩토리 오브젝트를 생성해야 하는 번거로움이 있다.

어플리케이션 컨텍스트를 사용하면 오브젝트 팩토리가 아무리 많아져도 이를 알아야하거나 직접 사용할 필요가 없다.

#### 2. 어플리케이션 컨텍스트는 종합 IoC 서비스를 제공해준다.
어플리케이션 컨텍스트의 역할은 단지 오브젝트 생성과 다른 오브젝트와의 관계 설정만이 전부가아니다.

오브젝트가 만들어지는 방식, 시점과 전략을 다르게 가져갈 수도 잇고, 이에 부가적으로 자동 생성, 오브젝트에 대한 후처리, 정보의 조합, 설정 방식의 다변화, 인터셉팅 등 오브젝트를 효과적으로 활용할 수 있는 다양한 기능을 제공한다.

또, 빈이 사용할 수 있는 기반기술 서비스나 외부 시스템과의 연동 등을 컨테이너 차원에서 제공해주기도 한다.

#### 3. 어플리케이션 컨텍스트는 빈을 검색하는 다양한 방법을 제공한다.
어플리케이션 컨텍스트의 getBean() 메서드는 빈의 이름을 이용해 빈을 찾아준다.

타입만으로 빈을 검색하거나 특별한 어노테이션 설정이 되어있는 빈을 찾을 수도 있다.

---

### 스프링 IoC 용어정리

#### 빈(Bean)
- 빈 또는 빈 오브젝트는 스프링이 IoC 방식으로 관리하는 오브젝트

  모든 오브젝트가 다 빈은 아니며, 스프링이 직접 그 생성과 제어를 담당하는 오브젝트만 빈이다.

#### 빈 팩토리(Bean Factory)
- 스프링의 IoC를 담당하는 컨테이너

  빈을 등록하고, 생성하고, 조회하고, 돌려주고 등 그 외 부가적인 빈을 관리하는 기능을 담당한다.
  
  보통은 이 빈 팩토리를 바로 사용하지 않고 이를 확장한 어플리케이션 컨텍스트를 이용한다.

#### 어플리케이션 컨텍스트(Application Context)
- 빈 팩토리를 확장한 IoC 컨테이너이다.

  빈을 등록하고 관리하는 기본적인 기능은 빈 팩토리와 동일하다.

  스프링이 제공하는 각종 부가 서비스를 추가로 제공한다.

  빈 팩토리는 빈의 생성과 제어의 관점에서!

  어플리케이션 컨텍스트는 스프링이 제공하는 어플리케이션 지원 기능을 모두 포함해서 이야기하는 것이다.

#### 컨테이너 또는 IoC 컨테이너(Container OR IoC-Container)
- IoC 방식으로 빈을 관리한다는 의미에서 어플리케이션 컨텍스트나 빈 팩토리를 컨테이너 또는 IoC컨테이너라고 한다.

  어플리케이션 컨텍스트는 그 자체로 ApplicationContext 인터페이스를 구현한 오브젝트를 가리키기도 하는데, 어플리케이션 컨텍스트 오브젝트는 하나의 어플리케이션에서 보통 여러 개가 만들어져 사용된다.

  이를 통틀어 스프링 컨테이너라고도 부른다.

---

> 오브젝트의 동일성과 동등성
>
> 자바에서는 두 개의 오브젝트가 완전히 같은 동일한(identical) 오브젝트라고 말하는 것과 동일한 정보를 담고 있는(equivalent) 오브젝트라고 말하는 것은 분명한 차이가 있다.
>
> 전자는 동일성 비교(== 연산자), 후자를 동등성 비교(equial() 메서드)
>
> 두 개의 오브젝트가 동일하다면 사실은 하나의 오브젝트만 존재하는 것이고, 두 개의 오브젝트 레퍼런스 변수를 갖고 있을 뿐인다.
>
> 두 개의 오브젝트가 동일하지는 않지만 동등한 경우에는 두 개의 각기 다른 오브젝트가 메모리에 존재하는 것인데,
>
> 오브젝트의 동등성 기준에 따라 두 오브젝트의 정보가 동등하다고 판단하는 것일 뿐이다.

```java
Dao Factory factory = new DaoFactory();
UserDao dao1 = factory.userDao();
UserDao dao2 = factory.userDao();

System.out.println(dao1); // UserDao@118f375
System.out.println(dao2); // UserDao@117a8bd
```
> userDao 를 매번 호출하면 위 코드와 동일하게 다른 값을 가진 동일하지 않은 오브젝트가 생긴다.\
>
> 그럼 스프링 어플리케이션 컨텍스트에 DaoFactory를 설정 정보로 등록하고 getBean() 메서드를 이용하여 오브젝트를 가져온다면?
```java
ApplicationContext context = new AnnotationConfigApplicationContext(DaoFactory.class);

UserDao dao3 = context.getBean("userDao", UserDao.class);
UserDao dao4 = context.getBean("userDao", UserDao.class);

System.out.println(dao3); // UserDao@ee22f7
System.out.println(dao4); // UserDao@ee22f7
```
> 두 오브젝트 출력 값이 같으므로, getBean()을 두 번 호출해서 가져온 오브젝트가 동일하다는 사실을 알 수 있다.
>
> 어플리케이션 컨텍스트는 싱글톤을 저장하고 관리하는 싱글톤 레지스트리이다.
> 스프링은 기본적으로 별다른 설정을 하지 않으면 내부에서 생성하는 빈 오브젝트를 모두 싱글톤으로 만든다.

---

### Q. 자바에서 싱글톤을 구현하는 방법
- 클래스 밖에서는 오브젝트를 생성하지 못하도록 생성자를 private으로 만든다.
- 생성된 싱글톤 오브젝트를 저장할 수 있는 자신과 같은 타입인 static 필드 정의
- static 팩토리 메서드인 getInstance()를 만들고 이 메서드가 최초로 호출되는 시점에 오브젝트를 생성한다.
  
  생성된 오브젝트는 static 필드에 저장한다.

  또는 static 필드의 초기 값으로 오브젝트를 미리 만들어둘 수도 있다.
- 한번 오브젝트가 만들어지고 난 후에는 getInstance() 메서드를 통해 이미 만들어져 static 필드에 저장해둔 오브젝트를 반환한다.

```java
public class UserDao {
  private static UserDao INSTANCE;
  ...
}
```

---

### Q. 싱글톤 패턴의 문제점
일반적으로 싱글톤 패턴 구현 방식에는 다음과 같은 문제가 있다.

#### 1. private 생성자를 갖고 있기 때문에 상속할 수 없다.
싱글톤 패턴은 생성자를 private으로 제한한다.

오직 싱글톤 클래스 자신만이 자기 오브젝트를 만들도록 제한하는 것이다.

객체지향의 장점인 상속과 이를 이용한 다형성을 적용할 수 없다.

#### 2. 싱글톤은 테스트하기 힘들다.
싱글톤은 테스트하기가 어렵거나 테스트 방법에 따라 아예 테스트가 불가능하다.

만들어지는 방식이 제한적이기 때문에 Mock 오브젝트 등으로 대체하기가 힘들다.

#### 3. 서버환경에서는 싱글톤이 하나만 만들어진다는 것을 보장하지 못한다.
서버에서 클래스 로더를 어떻게 구성하는지에 따라 싱글톤 클래스임에도 하나 이상의 오브젝트가 만들어진다.

따라서 싱글톤이 꼭 보장하지 않는다.

여러 개의 JVM이 분산돼서 설치가 되는 경우에도 각각 독립적으로 오브젝트가 생기기 때문에 싱글톤으로서의 가치가 떨어진다.

#### 4. 싱글톤 상용은 전역 상태를 만들 수 있기 때문에 바람직하지 못하다.
싱글톤은 사용하는 클라이언트가 정해져있지 않다.

static 메서드를 이용해 언제든지 싱글톤에 쉽게 접근할 수 있기 때문에 어플리케이션 어디서든지 사용될 수 있다.

그러다보다면 자연스럽게 전약 상태로 사용되기 쉽다.

---

### Q. 싱글톤 레지스트리
스프링은 서버환경에서 싱글톤이 만들어져 서비스 오브젝트 방식으로 사용되는 것을 적극 지지한다.

하지만 자바의 기본적인 싱글톤 패턴의 구현 방식은 여러가지 단점이 있기 때문에 스프링은 직접 싱글톤 형태의 오브젝트를 만들고 관리하는 기능을 제공한다.

이것이 "싱글톤 레지스트리"이다.

#### 장점
- static 메서드와 private 생성자를 사용해야 하는 비정상적인 클래스가 아니라 평범한 자바 클래스를 싱글톤으로 활용하게 해준다.
  오브젝트 생성에 관한 모든 권한은 IoC기능을 제공하는 어플리케이션 컨텍스트가 있기 때문이다.
  
- 싱글톤 패턴과 달리 스프링이 지지하는 객체지향적인 설계 방식과 원칙, 디자인 패턴 등을 적용하는데 아무런 제약이 없다.

#### 스프링이 빈을 싱글톤으로 만드는 것은 결국 오브젝트 생성 방법을 제어하는 IoC 컨테이너로서의 역할이다.

---

### Q. 멀티스레드 환경에서 싱글톤
싱글톤은 멀티스레드 환경이라면 여러 스레드가 동시에 접근해서 사용할 수 없다.

따라서 상태 관리에 주의를 기울여야한다.

싱글톤이 멀티스레드 환경에서 서비스 형태의 오브젝트로 사용되는 경우에는 상태정보를 내부에 갖고 있지 않은 무상태(stateless) 방식으로 만들어져야 한다.

다중 사용자의 요청을 한꺼번에 처리하는 스레드들이 동시에 싱글톤 오브젝트의 인스턴스 변수를 수정하는 것은 매우 위험하다.

저장할 때 공간이 하나뿐이니 서로 값을 덮어쓰고 자신이 저장하지 않은 값을 읽어올 수 있기 때문이다.

따라서 싱글톤은 기본적으로 인스턴스 필드의 값을 변경하고 유지하는 상태유지 방식으로 만들지 않는다.
```java
public class UserDao {
  private ConnectionMaker connectionMaker; // 초기 설정 시 사용 중에는 바뀌지 않는 읽기전용 인스턴스 변수

  private Connection c;
  private User user;
  // 매번 새로운 값으로 바뀌는 정보를 담은 인스턴스 변수이다.
  // 심각한 문제가 발생할 수 있다.
}
```
위 코드에서 connectionMaker는 DaoFactory에서 @Bean을 붙여서 만들었으니 스프링이 관리하는 빈이 될 것이고, 별다른 설정이 없다면 기본적으로 오브젝트 한 개만 만들어져서 UserDao의 connectionMaker 인스턴스 필드에 저장된다.

이렇게 자신이 사용하는 다른 싱글톤 빈을 저장하려는 용도라면 인스턴스 변수를 사용해도 좋다.

스프링이 한 번 초기화해주고 나면 이후에는 수정되지 않기 때문에 멀티스레드 환경에서 사용해도 아무런 문제가 없다.

동일하게 읽기전용의 속성을 가진 정보라면 싱글톤에서 인스턴스 변수로 사용해도 좋다.

물론 단순한 읽기전용 값이라면 static final이나 final로 선언되는 편이 나을 것이다.

---

### Q. 스프링 빈의 스코프

스프링이 관리하는 오브젝트, 즉 빈이 생성되고, 존재하고, 적용되는 범위

이것을 빈의 스코프(Bean Scope)라고 한다.

스프링 빈의 기본 스코프는 싱글톤이다.

싱글톤 스코프는 컨테이너 내에 한 개의 오브젝트만 만들어져서, 강제로 제거하지 않는 한 스프링 컨테이너가 존재하는 동안 계속 유지된다.

스프링에서 만들어지는 대부분의 빈은 싱글톤 스코프를 갖는다.

경우에 따라서는 싱글톤 외 스코프를 가질 수 있는데, 대표적으로는 프로토타입 스코프가 있다.

프로토타입은 싱글톤과 달리 컨테이너에 빈을 요청할 때마다 매번 새로운 오브젝트를 만들어준다.

그 외에도 요청 스코프(Request Scope), 세션 스코프(Session Scope)가 존재한다.

---

Q. 의존관계

의존관계란 무엇인지 생각해보자.

두 개의 클래스 또는 모듈이 의존관계에 있다고 말할 때는 항상 방향성을 부여해줘야 한다.

즉, 누가 누구에게 의존하는 관계에 있다는 식이어야 한다.

UML 모델에서는 두 클래스의 의존관계를 점선으로 된 화살표로 표현한다.

A가 B에 의존하고 있음을 나타낸다.

![image](https://github.com/user-attachments/assets/7bc81d55-8e82-4d56-8cc6-c55e947b102a)

그렇다면 의존하고 있다는 건 무슨 의미일까?

의존한다는 건 의존대상, 여기서는 B가 변하면 그것이 A에 영향을 미친다는 뜻이다.

B의 기능이 추가되거나 변경되거나, 형식이 바뀌거나 하면 그 영향이 A로 전달된다는 것이다.

B의 형식은 그대로지만 기능이 내부적으로 변경되면, 결과적으로 A의 기능이 수행되는 데도 영향을 미칠 수 있다.

이렇게 사용의 관계에 있는 경우에 A와 B는 의존관계가 있다고 말할 수 있다.

의존관계에는 방향성이 있다.

A가 B에 의존하고 있지만, 반대로 B는 A에 의존하지 않는다.

의존하지 않는다는 말은 B는 A의 변화에 영향을 받지 않는다는 뜻이다.

---

### Q. UserDao의 의존관계

![image](https://github.com/user-attachments/assets/18779bb9-494f-4b92-ba84-3fefa16be0b5)

UserDao가 ConnectionMaker 인터페이스를 사용하는 것을 나타낸다.

즉, UserDao는 ConnectionMaker 인터페이스에 의존하고 있다.

따라서 ConnectionMaker 인터페이스가 변한다면 그 영향을 UserDao가 직접적으로 받게 된다.

하지만 ConnectionMaker 인터페이스를 구현한 클래스, 즉 DConnectionMaker 등이 다른 것으로 바뀌거나 그 내부에서 사용하는 메서드가 변화가 생겨도 UserDao에는 영향을 주지 않는다.

이렇게 인터페이스에 대해서만 의존관계를 만들어두면 인터페이스 구현 클래스와의 관계는 느슨해지면서 변화에 영향을 덜 받는 상태가 된다.

결합도가 낮다고 설명할 수 있다.

의존관계란 한쪽의 변화가 다른 쪽에 영향을 주는 것이라고 했으니, 인터페이스를 통해 의존관계를 제한해주면 그만큼 변경에서 자유로워지는 셈이다.

---

> **의존 오브젝트(Dependent Object)** : 런타임 시에 의존관계를 맺는 대상, 즉 실제 사용대상인 오브젝트

---

### Q. 의존관계 주입

의존관계 주입은 구체적인 의존 오브젝트와 그것을 사용할 주체, 보통 클라이언트라고 부르는 오브젝트를 런타임 시에 연결해주는 작업을 말한다.

정리하면 의존관계 주입이란 다음과 같은 세 가지 조건을 충족하는 작업이다.

  1. 클래스 모델이나 코드에는 런타임 시점의 의존관계가 드러나지 않는다.
     그러기 위해서는 인터페이스에만 의존하고 있어야한다.

  2. 런타임 시점의 의존관계는 컨테이너나 팩토리 같은 제3의 존재가 결정한다.

  3. 의존관계는 사용할 오브젝트에 대한 레퍼런스를 외부에서 제공(주입)해줌으로써 만들어진다.

의존관계 주입의 핵심은 설계 시점에는 알지 못했던 두 오브젝트의 관계를 맺도록 도와주는 제3의 존재가 있다는 것이다.

DI에서 말하는 제3의 존재는 바로 관계설정 책임을 가진 코드를 분리해서 만들어진 오브젝트라고 볼 수 있다.

전략 패턴에 등장하는 클라이언트나 앞에서 만들었던 DaoFactory, 또 DaoFactory 같은 작업을 일반화해서 만들어졌다는 스프링의 어플리케이션 컨텍스트, 빈 팩토리, IoC 컨테이너 등이 모두 외부에서 오브젝트 사이의 런타임 관계를 맺어주는 책임을 지닌 제3의 존재라고 볼 수 있다.

---

### Q. UserDao의 의존관계 주입
```java
// 관계설정 책임 분리 전의 생성자
public UserDao() {
  connectionMaker = new DConnectionMaker();
}
```

주입이라는 건 외부에서 내부로 무엇인가를 넘겨줘야 하는 것인데, 자바에서 오브젝트에 무엇인가를 넣어준다는 개념은 메소드를 실행하면서 파라미터로 오브젝트의 레퍼런스를 전달해주는 방법뿐이다.

가장 손쉽게 사용할 수 있는 파라미터 전달이 가능한 메서드는 바로 생성자다.

DI 컨테이너는 자신이 결정한 의존관계를 맺어줄 클래스의 오브젝트를 만들고 이 생성자의 파라미터로 오브젝트의 레퍼런스를 전달해준다.

```java
// 의존관계 주입을 위한 코드
public class UserDao {
  private ConnectionMaker connectionMaker;

  public UserDao(ConnectionMaker connnectionMaker) {
    this.connectionMaker = connectionMaker;
  }
}
```

이렇게 생성자 파라미터를 통해 전달받은 런타임 의존관계를 갖는 오브젝트는 인스턴스 변수에 저장해둔다.

DI 컨테이너에 의해 런타임 시에 의존 오브젝트를 사용할 수 있도록 그 레퍼런스를 전달받는 과정이 마치 메서드(생성자)를 통해 DI 컨테이너가 UserDao에게 주입해주는 것과 같다고 해서 이를 "의존관계 주입"이라고 한다.

---

### Q. DI 컨테이너 OR DI 프레임워크
DI는 자신이 사용할 오브젝트에 대한 선택과 생성 제어권을 외부로 넘기고 자신은 수동적으로 주입받은 오브젝트를 사용한다는 점에서 IoC의 개념에 잘 들어맞는다.

스프링 컨테이너의 IoC는 주로 의존관계 주입 또는 DI라는 데 초점이 맞춰져 있다.

그래서 스프링을 IoC 컨테이너 외에도 DI 컨테이너 또는 DI 프레임워크라고 부른다.

---

### Q. 의존관계 검색

스프링이 제공하는 IoC방법에는 의존관계 주입만 있는 것이 아니다.

코드에서는 구체적인 클래스에 의존하지 않고, 런타임 시에 의존관계를 결정한다는 점에서 의존관계 주입과 비슷하지만, 의존관계를 맺는 방법이 외부로부터의 주입이 아니라 스스로 검색을 이용하기 때문에 "의존관계 검색"이라고 하는 것도 있다.

의존관계 검색은 자신이 필요로 하는 의존 오브젝트를 능동적으로 찾는다.

물론 자신이 어떤 클래스의 오브젝트를 이용할지 결정하지는 않는다.

의존관계 검색은 런타임 시 의존관계를 맺을 오브젝트를 결정하는 것과 오브젝트의 생성작업은 외부 컨테이너에게 IoC로 맡기지만, 이를 가져올 때는 메소드나 생성자를 통한 주입 대신 스스로 컨테이너에게 요청하는 방법을 사용한다.
```java
// DaoFactory를 이용하는 생성자
public UserDao() {
  DaoFactory daoFactory = new DaoFactory();
  this.connectionMaker = daoFactory.connectionMaker();
}
```

적용 방법은 외부로부터의 주입이 아니라 스스로 IoC 컨테이너인 DaoFactory에게 요청하는 것이다.

미리 준비된 메소드를 호출하면 되니까 단순히 요청으로 보이겠지만, 이런 작업을 일반화한 스프링의 어플리케이션 컨텍스트라면 미리 정해놓은 이름을 전달해서 그 이름에 해당하는 오브젝트를 찾게 된다.

따라서 이를 일종의 검색이라고 볼 수 있다.

또한 그 대상이 런타임 의존관계를 가질 오브젝트이므로 의존관계 검색이라고 부르는 것이다.

스프링 IoC 컨테이너인 어플리케이션 컨텍스트는 getBean()이라는 메소드를 제공한다.

바로 이 메소드가 의존관계 검색에 사용되는 것이다.

```java
public UserDao() {
  AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(DaoFactory.class);
  this.connectionMaker = context.getBean("connectionMaker", ConnectionMaker.class);
}
```

의존 관계 검색은 기존 의존관계 주입의 거의 모든 장점을 가지고 있다.

코드를 보면 느낄 수 있지만 의존관계 주입 쪽이 훨씬 단순하고 깔끔하며 검색 방법은 코드 안에 오브젝트 팩토리 클래스나 스프링 API가 나타난다.

따라서 대개는 의존관계 주입 방식을 사용하는 편이 낫다.

---

### Q. 의존관계 검색과 주입의 차이점

의존관계 검색 방식에서는 검색하는 오브젝트는 자신이 스프링의 빈일 필요가 없다는 점이다.

---

### Q. 런타임 시 사용 의존관계를 맺을 오브젝트를 주입해준다는 DI 기술의 장점

코드에는 런타임 클래스에 대한 의존관계가 나타나지 않고, 인터페이스를 통해 결합도가 낮은 코드를 만드므로, 다른 책임을 가진 사용 의존관계에 있는 대상이 바뀌거나 변경되더라도 자신은 영향을 받지 않으며, 변경을 통한 다양한 확장 방법에는 자유롭다는게 장점이다.

---

### Q. 생성자가 아닌 일반 메서드를 이용해 의존 오브젝트와의 관계를 주입해주는 2가지 방법

#### 1. 수정자 메서드를 이용한 주입

수정자(setter) 메서드는 외부에서 오브젝트 내부의 속성 값을 변경하려는 용도로 주로 사용된다.

메서드는 항상 set으로 시작한다.

수정자 메서드의 핵심기능은 파라미터로 전달된 값을 보통 내부의 인스턴스 변수에 저장하는 것이다.

수정자 메서드는 외부로부터 제공받은 오브젝트 레퍼런스를 저장해뒀다가 내부의 메서드에서 사용하게 하는 DI 방식에서 활용하기 적당하다.

#### 2. 일반 메서드를 이용한 주입

수정자 메서드처럼 set으로 시작해야 하고 한 번에 한 개의 파라미터만 가질 수 있다는 제약이 싫다면 여러 개의 파라미터를 갖는 일반 메소드를 DI용으로 사용할 수 있다.

생성자가 수정자 메서드보다 나은 점은 한 번에 여러 개의 파라미터를 받을 수 있다는 점이다.

하지만 파라미터의 개수가 많아지고 비슷한 타입이 여러 개라면 실수하기 쉽다.

```java
// 수정자 메서드 DI 방식을 사용한 UserDao
public class UserDao {
  private ConnectionMaker connectionMaker;

  public void setConnectionMaker(ConnectionMaker connectionMaker) {
    this.connectionMaker = connectionMaker;
  }
}
```

```java
// 수정자 메서드 DI를 사용하는 팩토리 메서드
@Bean
public UserDao userDao() {
  UserDao userDao = new UserDao();
  userDao.setConnectionMaker(connectionMaker());

  return userDao;
}
```

---

### Q. XML

DI 의존관계 설정정보를 만들 수 있는 가장 대표적인 방법이 XML이다.

XML은 단순한 텍스트 파일이기 때문에 다루기 쉽다.

또, 쉽게 이해할 수 있으며 컴파일과 같은 별도의 빌드 작업이 없다는 것이 장점이다.

환경이 달라져서 오브젝트의 관계가 바뀌는 경우에도 빠르게 변경사항을 반영할 수 있다.

스키마나 DTD를 이용해서 정해진 포맷을 따라 작성됐는지 손쉽게 확인할 수도 있다.

---

### Q. XML 설정

스프링의 어플리케이션 컨텍스트는 XML에 담긴 DI 정보를 활용할 수 있다.

DI 정보가 담긴 XML 파일은 <beans>를 루트 엘리먼트로 사용한다.

<beans> 안에는 여러 개의 <bean>을 정의할 수 있다.

XML 설정은 @Configuration과 @Bean이 붙은 자바 클래스로 만든 설정과 내용이 동일하다.

@Configuration을 <beans>, @Bean을 <bean>에 대응해서 생각하면 이해하기 쉽다.

하나의 @Bean 메소드를 통해 얻을 수 있는 빈의 DI 정보는 다음 3가지이다.
#### 1. 빈의 이름
  - @Bean 메소드 이름이 빈의 이름이다.
   
    이 이름은 getBean()에서 사용된다.

#### 2. 빈의 클래스
  - 빈 오브젝트를 어떤 클래스를 이용해서 만들지를 정의한다.

#### 3. 빈의 의존 오브젝트
  - 빈의 생성자나 수정자 메서드를 통해 의존 오브젝트를 넣어준다.

    의존 오브젝트도 하나의 빈이므로 이름이 있을 것이고, 그 이름에 해당하는 메서드를 호출해서 의존 오브젝트를 가져온다.

    의존 오브젝트는 하나 이상일 수도 있다.

---

### Q. connectionMaker() 전환

DI 정의 3가지 중에서 빈의 이름과 빈 클래스, 두 가지를 <bean> 태그의 id와 class 어트리뷰트를 이용해 정의할 수 있다.

#### 클래스 설정과 XML 설정의 대응항목

||자바 코드 설정정보|XML 설정정보|
|---|---|---|
|빈 설정파일|@Configuration| <`beans`> |
|빈의 이름|@Bean methodName()|<bean id="methodName"|
|빈의 클래스|return new BeanClass();|class="a.b.c...BeanClass">|

단, <bean> 태그의 class 어트리뷰트에 지정하는 것은 자바 메소드에서 오브젝트를 만들 때 사용하는 클래스 이름이라는 점에 주의하자.

메서드의 리턴 타입을 class 어트리뷰트에 사용하지 않도록 하자.

XML에서는 리턴하는 타입을 지정하지 않아도 된다.

class 어트리뷰트에 넣을 클래스 이름은 패키지까지 모두 포함해야 한다.

---

### Q. userDao() 전환

스프링 개발자가 수정자 메소드를 선호하는 이유 중에는 XML로 의존관계 정보를 만들 때 편리하다는 점도 있다.

<property> 태그는 name과 ref라는 두 개의 어트리뷰트를 갖는다.

name은 프로퍼티의 이름이다.

이 프로퍼티의 이름으로 수정자 메서드를 알 수 있다.

ref는 수정자 메소드를 통해 주입해줄 오브젝트의 빈 이름이다.

```java
userDao.setConnectionMaker(connectionMaker());

<property name="connectionMaker" ref="connectionMaker" />
```

마지막으로 이 <property> 태그를 userDao 빈을 정의한 <bean> 태그 안에 넣어주면 된다.

---

같은 인터페이스 타입의 빈을 여러 개 정의한 경우 다음 줄에 작성하면 된다.

```html
<beans>
  <bean id="localDBConnectionMaker" class="...LocalDBConnectionMaker" />
  <bean id="testDBConnectionMaker" class="...TestDBConnectionMaker" />
  <bean id="productionDBConnectionMaker" class="...ProductionDBConnectionMaker" />

  ...
</beans>
```

---

### Q. 프로퍼티 값 주입

수정자 메소드에는 다른 빈이나 오브젝트뿐 아니라 스트링 같은 단순 값을 넣어줄 수도 있다.

텍스트나 단순 오브젝트 등을 수정자 메소드에 넣어주는 것을 스프링에서는 '값을 주입한다'고 말한다.

성격은 다르지만 일종의 DI라고 볼 수 있다.

사용할 오브젝트 자체를 바꾸지는 않지만 오브젝트의 특성은 외부에서 변경할 수 있기 때문이다.

---

## 정리
스프링의 관심은 오브젝트와 그 관계이다.

하지만 오브젝트를 어떻게 설계하고, 분리하고, 개선하고, 어떤 의존관계를 가질지 결정하는 일은 스프링이 아니라 개발자의 역할이며 책임이다.











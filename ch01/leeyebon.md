## 스프링이란?

자바 엔터프라이즈 어플리케이션 개발에 사용되는 애플리케이션 프레임워크이다. 애플리케이션의 바탕이 되는 틀과 공통 프로그래밍 모델, 기술 API 등을 제공해준다.

### 스프링 컨테이너

스프링 컨테이너라는 스프링 런타임 엔진을 제공하는데, 이는 설정 정보를 참고해서 어플리케이션을 구성하는 오브젝트를 생성하고 관리한다. 스프링을 사용하려면 스프링 컨테이너를 다루는 방법과 설정 정보를 작성하는 방법에 대해 알아야 한다.

### 공통 프로그래밍 모델

애플리케이션 코드를 작성하는 틀 세가지 모델을 지원한다.

- IoC/DI: 오브젝트의 생명주기와 의존관계에 대한 프로그래밍 모델. 객체 지향 설계 원칙과 디자인 패턴의 핵심 원리를 담고 있음
- 서비스 추상화: 스프링을 사용하면 환경이나 서버, 특정 기술에 종속되지 않고 이식성이 뛰어나며 유연한 어플리케이션을 만들 수 있음.
- AOP: 부가적인 공통 기능을 독립적으로 모듈화해서 사용할 수 있는 모델.

### 기술 API

UI 작성뿐만 아니라, 웹 프레젠테이션 계층, 비즈니스 서비스 계층, 기반 서비스 계층, 도메인 계층, 데이터 엑세스 계층 등에서 필요한 기술을 스프링에서 일관된 방식으로 사용할 수 있도록 지원해주는 기능과 전략 클래스를 제공한다.

<aside>
💡

스프링이 어떤 것이고, 무엇을 제공하는지보다는 스프링이 관심을 갖는 대상인 오브젝트의 설계와 구현, 동작원리에 집중해야 한다.

</aside>

## 1.1 초난감 DAO

DAO: DB를 사용해 데이터를 조회하거나 조작하는 기능을 전담하도록 만든 오브젝트

### 1.1.1  User

사용자 정보를 담은 클래스 User는 자바빈 규악을 따르는 오브젝트를 이용하면 편리하게 사용자 정보를 저장할 수 있다. (자바)빈은 두 가지 관례에 따라 만들어진 오브젝트를 의미한다.

- 디폴트 생성자: 파라미터가 없는 디폴트 생성자를 갖고 있어야 하는데 이는 툴이나 프레임워크에서 리플렉션을 이용해 오브젝트를 생성하기 때문이다.
- 프로퍼티: 객체가 가지는 속성을 의미하는데 이는 setter, getter를 활용해 데이터 수정 및 조회가 가능하다.

### 1.1.2 UserDao

사용자 정보를 DB에 넣고 관리할 수 있는 DAO 클래스에서는 연결하고자 하는 DB 정보, SQL query 등 DB 데이터를 사용하기 위한 로직들이 포함된다.

### 1.1.3 main()을 이용한 DAO 테스트 코드

가장 간단하게 코드를 테스트 하는 방법은 해당 오브젝트 스스로 검증하도록 만들어 주는 것이다. 모든 클래스에는 main()을 활용해 실행이 가능하다. 책의 내용대로 User 객체를 임의로 만들어 이를 dao 객체에 담아 add와 get 메서드를 실행되는 것을 확인할 수 있다.

테스트 진행하였을 때, 외부의 문제(db 관련 이슈)가 아니라면 코드는 문제 없이 잘 작동된다. 하지만 ‘어쨌든 잘 작동하는’ 코드는 스프링의 편리함을 고려하지 않았다. 코드를 수정해가면서 스프링에 대해 더 깊이 공부하는 시간을 가졌다.

## 1.2 DAO의 분리

### 1.2.1 관심사의 분리

사용자의 비지니스 프로세스와 그에 따른 요구사항은 끊임없이 바뀌고 발전한다. 우리는 이처럼 변경에 유연하게 대비할 수 있는 노력을 기울여야 한다.

절차지향프로그래밍과 다르게 객체지향프로그래밍은 실세계를 최대한 가깝게 모델링하는 작업을 하기 때문에 변화에 대응하는 것에 집중하고 설계한다.

변경의 범위를 최소화해 변경이 발생하였을 때 기존에 잘 작동되는 모듈의 오류가 발생하는 것을 방지하는 것을 목적으로 한다. 즉, 분리와 확장을 고려한 설계를 진행해야 한다.

변화가 한 번에 한 가지 관심에 집중돼서 일어난다면, 한 가지 관심이 한 군데에 집중되게 하는 것이다. 관심사가 같은 것은 하나로 묶고, 관심이 다른 것은 다른 곳으로 분리한다.

### 1.2.2 커넥션 만들기의 추출

- UserDao의 관심사항
    - DB와 연결을 위한 커넥션을 어떻게 가져올까, 어떠한 DB를 사용하고 어떤 정보를 가져와야 할까와 같이 DB 연결과 관련된 관심
    - SQL 문장을 담을 Statement를 만들고 실행하는 것. 파라미터로 넘어온 객체 프로퍼티 값을 바인딩시키고 쿼리가 실행되는 것에 대한 관심
    - 작업이 끝나고 리소스를 닫아 누수를 막는 것에 대한 관심

위의 세가지 관심사항이 하나의 코드, 그 중에서도 하나의 메서드 안에 들어가 있다. 이 와중에 예외 처리에 대한 내용은 포함되어 있지 않아 불안정한 상태이다.

DB 연결과 관련된 코드는 심지어 add 메서드에만 존재하는 것이 아닌 get 메서드 안에도 포함되어 중복된 코드로 자리잡고 있다. 이에 대한 분리가 필요하다.

1. 중복 코드의 메서드 추출
    
    getConnection 이라는 메서드를 만들어 DB 연결에 대한 관심사를 분리해준다. 결과적으로, 이후 DB 연결 정보가 변경되면 기존에 add와 get 메서드 각각의 db 연결 코드를 수정할 필요 없이 getConnection 메서드 하나에서만 수정을 하게 되면 이를 활용하는 모든 메서드에도 적용이 가능하다.
    
2. 변경 사항에 대한 검증: 리팩토링과 테스트
    
    1번에서 진행한 중복 코드 메서드를 추출하는 리팩토링 기법을 ‘메서드 추출’ 기법이라고 불린다. 이에 대한 테스트를 진행하려면 main() 메스드를 실행하면 되는데, 두번 실행하게 되면 기존에 add 한 내용이 포함되어 데이터가 중복으로 들어간다. 따라서 해당 데이터를 삭제해주는 초기화 작업이 필요하다.
    

### 1.2.3 DB 커넥션 만들기의 독립

이제는 변화에 대응하는 수준이 아닌, 변화를 반기는 수준으로 리팩토링을 진행해보려고 한다.

- 상속을 통한 확장
    - getConnection 메서드를 추상 클래스로 만든다.
    - 구현 클래스는 각 고객사에게 따로 제공이 가능하다.

이처럼 상속을 활용해 클래스 확장을 하는 방법은 템플릿 메서드 패턴, 팩토리 메서드 패턴이 대표적으로 많이 사용된다.

- 템플릿 메서드 패턴: 기본적인 로직의 흐름을 만들고 그 중 일부를 추상 메서드나 오버라이딩이 가능한 protected 메서드 등으로 만들어 서브클래스에서 필요에 따라 구현해 사용하는 패턴
- 팩토리 메서드 패턴:  서브 클래스에서 구체적인 오브젝트 생성 방법을 결정하게 하는 패턴

## 1.3 DAO의 확장

상속을 활용해 관심사를 분리하는 방법에는 한계가 존재할 수 있다. 클래스간 다중 상속이 불가능하다는 것인데, getConnection 메서드는 다른 DAO에서 활용하게 되면은 그만큼 getConnection 메서드가 중복적으로 생겨난다는 문제가 존재한다.

### 1.3.1 클래스의 분리

두 개의 관심사를 더 확실하게 분리하고 동시에 쉽게 확장할 수 있는 방법에 대해 알아본다.

이전 예시에서 DB 커넥션에 대한 클래스를 서브 클래스가 아닌 독립적인 클래스로 정의한다. 이 방식을 통해 확실하게 관심사를 분리할 수 있지만 DB 연결을 확장시킨 방식을 사용할 수 없다는 단점이 발생했다.

### 1.3.2 인터페이스의 도입

이때 인터페이스라는 추상화 도구를 활용하면 UserDAO와 ConnectionMaker 클래스 간의 연결을 느슨하게 할 수 있다. 그러나 UserDAO에서 ConnectionMaker 클래스에 대한 인스턴스 변수를 생성자로 불러오기 때문에 의존 관계가 엮여 있다.

### 1.3.3 관계설정 책임의 분리

위와 같은 문제를 해결하기 위해서는 어떠한 객체(인터페이스의 구현체 클래스 중에서?)를 선택할 것인지에 대한 관심사를 분리해야 한다.

이번 예시에서는 클라이언트가 누구냐에 따라서 인터페이스의 어떤 구현체 클래스를 활용하는지가 결정된다. 즉 런타임 시 결정된다. 이를 구현하기 위해서는 테스트 코드인 main() 에서 클라이언트가 누구인지를 파라미터를 통해 결정시켜 로직을 수행하게 할 수 있다.

이를 통해 UserDao에서 관심사가 아닌 ConnectionMaker를 클라이언트 요청을 처리하는 Test 코드로 위임할 수 있게 되었다.

### 1.3.4 원칙과 패턴

- 개방-폐쇄 원칙(OCP): 클래스나 모듈은 확장에 열려있어야 하고, 변경에는 닫혀있어야 한다. 기존의 초난감 DAO 상태와 인터페이스를 통해 관심사의 분리와 확장으로 리팩토링한 코드를 비교하면 OCP가 잘 지켜졌음을 알 수 있다.
- 높은 응집도와 낮은 결합도: 하나의 모듈 안에 공통된 관심사가 모여있을수록 응집도가 높다고 할 수 있는데, 이는 결국 해당 모듈에 작은 변화가 생기더라도 많은 부분이 함께 바뀐다. 낮은 결합도는 책임과 관심사가 다른 모듈이나 오브젝트 간에는 느슨하게 연결된 형태를 유지해야 한다는 것을 의미한다. 변경에 대한 전파율이 낮음을 의미한다.
- 전략 패턴: 자신의 맥락에서 필요에 따라 변경이 필요한 알고리즘을 인터페이스를 통해 통째로 외부로 분리시키고, 이를 구현한 구체적인 알고리즘 클래스를 필요에 따라 바꿔서 사용할 수 있게 하는 디자인 패턴이다.

## 1.4 제어의 역전(IoC)

### 1.4.1 오브젝트 팩토리

이전의 UserDao 관련한 코드에서 UserDaoTest의 역할에 대해 다시 생각해봐야 한다. UserDaoTest는 UserDao 클래스가 정상적으로 작동하는지를 확인하기 위한 목적에 있다. 그러나 클라이언트의 역할을 분리하는 책임까지 맡고 있기에 이에 대한 분리를 수행하고자 한다.

- 팩토리: 이 클래스의 역할은 객체의 생성 방법을 결정하고 그렇게 만들어진 오브젝트를 돌려주는 역할을 한다.

### 1.4.2 오브젝트 팩토리의 활용

DaoFactory 코드 안에서 UserDao에 대한 ConnectionMaker 객체를 만들어줬는데, 만일 이외에도 다른 Dao가 생기게 되면 이에 대한 ConnectionMaker 객체를 만드는 코드가 중복으로 생기게 된다.

이를 분리해서 이전에 언급했던 ‘메서드 추출’ 기법을 활용할 수 있다.

### 1.4.3 제어권의 이전을 통한 제어관계 역전

제어의 역전이란 제어 흐름의 개념을 거꾸로 뒤집는 것이다. 제어의 역전에서는 오브젝트가 자신이 사용할 오브젝트를 스스로 선택하지 않는다. 서블릿을 예시로 들면 서버에 배포할 수 있지만 제어에 대한 권한은 서블릿 자체에 없고 컨테이너에게 위임되어 있다.

즉, 제어권을 상위 템플릿 메서드에게 넘기고 자신은 필요할 때 호출되어 사용되도록하는 제어의 역전 개념이 UserDao에도 존재한다.

## 1.5 스프링의 IoC

### 1.5.1 오브젝트 팩토리를 이용한 스프링 IoC

- 애플리케이션 컨텍스트와 설정정보
    
    스프링에서는 빈의 생성과 관계 설정과 같은 제어를 담당하는 IoC 오브젝트를 빈 팩토리라고 부른다.
    
    DaoFactory 자체가 설정정보를 담고 있는 IoC 엔진이었는데, 조금만 손보면 자바 코드로 만든 어플리케이션 컨텍스트의 설정정보로 활용 가능하다.
    
- DaoFactory를 사용하는 어플리케이션 컨텍스트
    
    스프링이 DaoFactory 클래스를 빈 팩토리가 사용할 수 있는 설정정보로 인식될 수 있게 어노테이션을 활용해 @Configuration 을 붙여준다. 그리고 오브젝트를 생성하는 메서드에는 @Bean 을 붙여 오브잭트 생성과 초기화 및 반환하는 기능을 만든다. ConnectionMaker 메서드도 마찬가지로 @Bean을 붙여준다.
    
    Configuration 어노테이션이 붙은 설정정보를 사용하는 어플리케이션 컨텍스트을 만들기 위해서 AnnotationConfigApplicationContext를 활용하면 된다.
    

이처럼 어플리케이션 컨텍스트로 DaoFactory를 활용하는 것과 기존에 DaoFactory를 직접 사용한 것과 큰 차이가 없다. 이후 내용을 통해 어떤 차이가 있는지 알아보자.

### 1.5.2 애플리케이션 컨텍스트의 동작 방식

오브젝트 팩토리를 사용한 방식과 스프링의 애플리케이션 컨텍스트를 사용한 방식을 비교해보았을 때 범용적인 애플리케이션 컨텍스트를 사용한 방식의 이점을 알아본다.

- 클라이언트는 구체적인 팩토리 클래스를 알 필요가 없다.
- 애플리케이션 컨텍스트는 종합 IoC 서비스를 제공해준다.
- 애플리케이션 컨텍스트는 빈을 검색하는 다양한 방법을 제공한다.

### 1.5.3 스프링 IoC의 용어 정리

- 빈
    
    IoC 방식으로 관리하는 오브젝트를 의미한다. 스프링이 직접 생성하고 제어하는 오브젝트만을 빈이라고 정의한다.
    
- 빈 팩토리
    
    스프링의 IoC를 담당하는 핵심 컨테이너이다. 빈을 등록하고, 생성하고, 조회하고 돌려주고, 그 외의 부가적인 빈을 관리하는 기능을 담당한다. 보통 바로 빈 팩토리를 사용하지 않고 확장된 개념인 애플리케이션 컨텍스트를 이용한다.
    
- 애플리케이션 컨텍스트
    
    빈 팩토리를 확장한 IoC 컨테이너이다. 빈을 관리하는 기본기능은 동일하다. 스프링이 제공하는 모든 애플리케이션 지원 기능을 포함한다.
    
- 설정정보/설정메타정보
    
    IoC를 적용하기 위해 사용하는 메타정보를 의미한다. IoC 컨테이너에 의해 관리되는 애플리케이션 오브젝트를 생성하고 구성할 때 사용된다.
    
- 컨테이너 또는 IoC컨테이너
    
    
- 스프링 프레임워크
    
    스프링이 제공하는 모든 기능(IoC 컨테이너, 애플리케이션 컨텍스트 모두 이 일부에 해당)
    

## 1.6 싱글톤 레지스트리와 오브젝트 스코프

<aside>
💡

오브젝트의 동일성과 동등성

오브젝트가 동일하다는 것은 완전히 같다는 의미에서 == 가 true 인 값이다. 이는 사실 하나의 오브젝트만 존재하는 것이다. 

오브젝트가 동등하다는 것은 두 개의 각기 다른 오브젝트가 동일한 정보를 담고 있는 것이다. 그렇기 때문에 .equals를 통해 비교가 가능하다.

결론적으로 동일한 오브젝트는 동등하지만 동등한 오브젝트라고 해서 동일한 오브젝트라고 말할 수는 없다.

</aside>

앞서 오브젝트 팩토리를 사용한 방식과 애플리케이션 컨텍스트를 활용한 방식에는 위와 같은 오브젝트의 동일성과 동등성 측면에서 다른 결과를 보인다. 오브젝트 팩토리를 사용한다면 동일하지 않고 동등한 오브젝트를 생성해내지만, 애플리케이션 컨텍스트를 활용한 방식은 동일한 오브젝트를 만들어내는 것이다.

### 1.6.1 싱글톤 레지스트리로서의 애플리케이션 컨텍스트

애플리케이션 컨텍스트는 싱글톤을 저장하고 관리하는 싱글톤 레지스트리라고 불리기도 한다. 기본적으로 설정하지 않으면 모두 싱글톤 스코프로 생성된다.

싱글톤은 공유 오브젝트라고 불리는데, 왜 스프링은 기본적으로 싱글톤을 사용하는가에 대해 알아보았다.

서버 하나당 최대로 초당 수십에서 수백 번씩 브라우저나 여타 시스템으로부터 요청을 받아 처리할 수 있는 높은 성능이 요구되는 환경에서 스프링이 처음 설계되었다. 매번 클라이언트 요청이 올때마다 새로운 오브젝트를 생성하게 된다면 부하가 커지고 서버는 감당할 수 없게 된다.

사용자의 요청을 담당하는 여러 스레드에서 하나의 오브젝트를 공유해 동시에 사용한다. 그렇기 때문에 서버의 부하를 효율적으로 관리할 수 있는 것이다.

<aside>
💡

싱글톤 오브젝트와 싱글톤 패턴은 다른 개념이라고 봐야 한다. 싱글톤 패턴은 어떤 클래스를 제한된 인스턴스, 변수, 주로 하나만 존재하도록 만드는 패턴을 의미한다. 이렇게 하나만 만들어지는 클래스의 오브젝트는 애플리케이션 내에서 전역적으로 접근이 가능하다. 단일 오브젝트만 존재해야 하고 애플리케이션 내 다른 영역에서 이를 공유해서 사용하기 위해 적용되는 패턴이다.

</aside>

싱글톤을 구현하는 방법은 다음과 같다.

- private으로 생성자를 만들어 클래스 밖에서는 생성하지 못하도록 강제한다.
- 싱글톤 오브젝트를 저장할 수 있는 스태틱 필드를 정의한다.
- 최초로 호출되는 시점에서 한번만 오브젝트가 만들어지게 한다. 그리고 스태틱 필드에 이를 저장한다.(초기값으로 컴파일 시점에 미리 초기화하는 방법도 있다.)
- 정적 팩토리 메서드로 만든 getInstance 메서드로 만들어진 오브젝트를 넘겨준다.

이러한 싱글톤 생성 방식으로 인해서 한계가 존재한다.

1. private 이기 때문에 상속이 불가능하다.
2. 싱글톤은 테스트하기 힘들다.
3. 여러 서버 환경에서 애플리케이션이 구동된다면 각 서버에서 싱글톤 오브젝트가 만들어져 그 의미가 퇴색된다.
4. 싱글톤의 사용은 전역 상태를 만들 수 있기 때문에 race condition이 발생할 수 있다.

싱글톤 레지스트리를 활용해 서버 환경에서 서비스 오브젝트 방식으로 사용되는 것은 적극적으로 지지하지만 싱글톤 패턴으로 만들어진 오브젝트는 단점이 많이 존재한다.

### 1.6.2 싱글톤과 오브젝트의 상태

전역적으로 사용 가능한 싱글톤 오브젝트이기 때문에 상태를 정의하게 된다면 멀티 스레드 환경에서 사용자 요청에 따른 상태 관리가 어렵다. 읽기 전용의 값이라면 상관없을 수 있겠지만.

### 1.6.3 스프링 빈의 스코프

기본적으로 스프링은 싱글톤 스코프의 오브젝트를 관리하지만 경우에 따라 다른 스코프의 오브젝트를 관리하기도 한다. 대표적으로는 프로토타입 스코프다. 이는 싱글톤 스코프와는 반대로 요청마다 오브젝트가 새로 생성된다는 특징이 있다.

## 1.7 의존관계 주입(DI)

스프링의 IoC에 대해 깊게 알아보자.

### 1.7.1 제어의 역전(IoC)과 의존관계 주입

IoC의 대표적인 기능은 의존관계 주입이다.

### 1.7.2 런타임 의존관계 설정

의존관계란?

두 모듈이 의존관계에 있다면 방향성이 존재하는데, A가 B에 의존한다고 하면 화살표의 방향이 A → B 를 의미한다. B가 변하면 A도 영향을 받는다. 반대로 B는 A의 변화에 영향을 받지 않는다.

이처럼 모델이나 코드 상에서의 의존관계말고도 런타임에서도 오브젝트간 의존관계가 존재할 수 있다. 런타임 시점에 모듈간의 의존관계가 정의될 때 런타임 의존관계가 존재한다고 말할 수 있다.

### 1.7.3 의존관계 검색과 주입

의존관계 검색은 기존 의존관계 주입의 장점을 모두 갖고 있다. 다만 방식이 다를 뿐이다. 대개는 의존관계 주입 방식을 선택하는 것이 낫다. 의존관계 검색 방식인 getBean을 사용하게 된다면 스프링이 UserDao를 직접 관리하지 않고 ConnectionMaker만 스프링 빈이면 된다는 점에서 차이가 존재한다.

### 1.7.4 의존관계 주입과 응용

DI 적용 방식을 활용하면 ConnectionMaker 에서 DB를 연결하는 방식에 있어 확장이 가능하다. LocalDB에 대한 연결 정보를 담은 클래스만 존재하면 이를 활용하는 DAO는 해당 클래스에 의존하게 된다. 그러나 LocalDB 이외에도 서버 DB를 활용한다면 이에 대한 클래스를 또 만들어줘서 의존하게 해야 하는데 이는 가용성이 떨어진다. 따라서 애플리케이션 컨텍스트를 활용해 빈으로 등록한 설정정보만 수정해 연결을 유연하게 변경하도록 하면 된다.

부가기능으로 얼마나 많은 DB 연결이 되고 있는지 확인하는 것 또한 DI를 활용할 수 있다. DAO와 DB 커넥션을 만들어주는 오브젝트 사이에 카운팅하는 오브젝트를 추가해주면 된다. 이는 어떠한 connectionMaker 오브젝트이든지간에 상관없이 횟수를 셀 수 있다는 장점이 있다.

### 1.7.5 메소드를 이용한 의존관계 주입

지금까지는 의존관계 주입을 위해 생성자를 활용하였다. 생성자가 아닌 일반 메서드를 활용해 의존 오브젝트와의 관계를 주입해주는 데에는 크게 두 가지 방법이 있다.

- 수정자 메서드를 이용한 주입
    
    외부에서 오브젝트 내부의 속성 값을 변경하려는 용도로 사용된다. 수정자 메서드는 외부로부터 제공받은 오브젝트 레퍼런스를 저장해놨다가 내부의 메소드에서 사용하게 하는 DI 방식에서 활용하기에 적합하다.
    
- 일반 메서드를 이용한 주입
    
    한 번에 한개의 파라미터만 가질 수 있다는 제약이 생기는게 싫을 때 사용하는 메서드 주입 방식이다.
    

XML을 사용하는 경우에는 자바빈 규약을 따르는 수정자 메서드 주입 방식이 편리하였다.

## 1.8 XML을 이용한 설정

XML은 단순한 텍스트 파일이기 때문에 다루기 쉽다. 컴파일과 같은 별도의 빌드 작업이 없어 번거롭지 않다는 장점도 있다. 이전에는 자바 코드를 활용해 DI를 위한 의존관계 정보를 만들었다면 XML을 활용해 만들어 보자.

### 1.8.1 XML 설정

같은 인터페이스의 빈을 정의할 때에는 독립적으로 빈을 생성하고 ref 애트리뷰트를 이용해 DI 받을 빈을 지정해주면 된다.

### 1.8.2 XML을 이용하는 애플리케이션 테스트

XML에서 빈의 의존관계 정보를 이용하는 IoC/DI 작업에는 GenericXmlApplicationContext를 이용한다. 해당 생성자의 파라미터로 XML 파일의 클래스패스를 지정하면 된다. 애플리케이션 컨텍스트가 사용하는 XML 설정파일의 명은 applicationContext.xml이라고 만든다. 

### 1.8.3 DataSource 인터페이스로 변환

이전에 ConnactionMaker는 직접 구현했었지만 이미 DataSource라는 구현이 완료되어 제공되는 DataSource가 있다. 이는 ClassNotFoundException 없이 SqlException 관련된 것만 존재한다. DataSource 구현 클래스를 참고해서 기존 코드르 변경할 수 있다.

### 1.8.4 프로퍼티 값의 주입

다른 빈 오브젝트의 레퍼런스가 아닌 단순 정보도 오브젝트를 초기화하는 과정에서 수정자 메서드를 넣을 수 있다. DI에서처럼 다이나믹하게 오브젝트의 구현 클래스를 변경하고 추가하는 것이 아니라 DB 연결정보와 같이 변경 가능한 정보를 설정하는 것에 목표를 둔다.

## 1.9 정리

- 관심사의 분리 리팩토링 수행
- 전략패턴을 활용해 클래스가 인터페이스에만 접근하게 하고 인터페이스의 각 구현체들에는 의존하지 않게 설계
- 위와 같은 전략패턴을 활용해 개방 폐쇄 원칙을 구현
- 낮은 결합도와 높은 응집도를 고려할 수 있게 됨
- 오브젝트가 생성되고 여타 오브젝트와 관계를 맺는 작업의 제어권을 별도의 오브젝트 팩토리를 만들어 넘김(IoC 컨테이너)
- 싱글톤 패턴의 구현 방식의 단점, 서비스 오브젝트로서의 장점을 살릴 수 있는 싱글톤을 사용하면서도 싱글톤 패턴의 단점을 극복(싱글톤 레지스트리)
- 설계 시점에서 클래스와 인터페이스간의 의존관계를 느슨하게 유지하고 런타임 시에는 실제 사용할 구체적인 의존 오브젝트를 DI 컨테이너의 도움을 받아 주입
- 생성자 주입과 수정자 주입
- XML 설정을 활용한 DI 설정정보 만드는 방법, 의존 오브젝트가 아닌 일반 값을 외부에서 설정해 런타임시 주입하는 방법